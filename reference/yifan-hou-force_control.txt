Directory structure:
└── yifan-hou-force_control/
    ├── README.md
    ├── CMakeLists.txt
    ├── LICENSE
    ├── .clang-format
    ├── include/
    │   └── force_control/
    │       ├── admittance_controller.h
    │       └── config_deserialize.h
    ├── scripts/
    │   └── plot.py
    └── src/
        ├── admittance_controller.cpp
        └── config_deserialize.cpp

================================================
FILE: README.md
================================================
# force_control
Implementations of 6D Cartesian space admittance control. Supports hybrid force-velocity control.

The algorithm creates a virtual spring-mass-damper-friction system using a position controlled robot. You can specify the following parameters:
* 6x6 stiffness matrix, inertia matrix, damper matrix, friction vector.

You can update the following online:
* Direction and dimension of force (soft) and position (rigid) control axes

Hardware requirements:
* A robot arm with high accuracy (high stiffness) position control interface.
* A wrist mounted FT sensor.

Author: Yifan Hou
yifanhou at stanford dot edu
# What is admittance control?
Admittance control is one of the two ways (the other is impedance control) to implement compliance control. Compliance control refers to methods to make a robot act compliantly via feedback control. Compliance is usually described by a spring-mass-damper system. For more details on how is compliance achieved, the difference between admittance and impedance, please checkout my [lecture notes on Compliance Control](https://www.dropbox.com/scl/fi/4xg3notqen0wrbkyk59i1/Intro_to_compliance_control.pdf?rlkey=qrm58807j5q4irl2viyrp2df7&e=2&dl=0).

# What is hybrid force-velocity control?
A robot usually lives in a multi-dimensional space. For example, a typical robot arm moves its hand in 6D rigid body space. When doing compliance control, you need to specify the compliant behavior you want in all those six dimensions.

Hybrid force-velocity control (or hybrid force-position control, just different names) refers to the act of using different compliance parameters (inertia, stiffness, damping) in different directions in this 6D space. This package lets you specify parameters in all six dimensions, as well as the directions of the six axes.

If you don't want HFVC and just want uniform compliance, that is easy to set too. See the examples below for how to do it.

# SAFETY WARNING
Force control is a high rate, high order control scheme that can go very wrong very quickly. Make sure you understand what you are doing before using this code. If the compliance parameters are not suitable, e.g. the robot is configured to be too soft and light while force feedback is not well calibrated, the robot will drift away very fast, which can be dangerous. 

For your own safety, the following steps are recommended before launching a force-controlled robot:
1. Start from enabling only one translational compliance axis (using `setForceControlledAxis`). Get the compliance control to work, get a feeling of what parameters make sense for your robot before enabling more axes. Common mistakes to pay attention to:
  * Force feedback transformation is wrong. This could cause a positive feedback loop.
  * Force sensor is badly calibrated.
  * Compliance parameters are set to be too senstitive (unstable motion) or too insensitive (no response to external force).
2. Safe parameters to use when testing for the first time:
  * Set the inertia value to the same magnitude as the actual robot mass. For example, 2~5kg is reasonable for a typical table top robot arm like ABB120, UR5e.
  * Set damping to a small value, e.g. 0.1
  * Set stiffness to a reasonable value.
  * direct_force_control_gains and direct_force_control_I_limit should be all zero.
3. Make sure the robot stays clear from any potential collisions.
4. Make sure you have the emergency stop button at your thumb.
5. Start to run the controller.
  * Stop immediately if there is any sudden/unstable motion.
  * If the robot appears to be stable, gently push the robot in the direction where you enabled compliance. Check if the robot can be dragged as expected. If not, check your sensor sign/transformation/robot tool frame setting, etc.
  * If the signs/direction seems fine but the robot is just shaking a bit, graduately increase damping.
6. Now you have a one-axis compliance control working. You can play with the parameters as you wish, e.g. graduately reduce the inertia values and damping to get a more "soft" feeling.
7. Enable all three translational axes.
8. Redo the above for rotational axes. Note the order of magnitude of parameters are quiet different between rotational and translational axes.

# Install
## Dependency
Please install the following packages:
* [cpplibrary](https://github.com/yifan-hou/cpplibrary)

## Build
``` sh
cd force_control
mkdir build && cd build
cmake ..
make -j
make install
```

# How to use
## Use with cmake
``` makefile
# replace ${CMAKE_INSTALL_PREFIX} with your install location
find_library(FORCE_CONTROLLERS FORCE_CONTROLLERS HINTS ${CMAKE_INSTALL_PREFIX}/lib/)
find_library(RUT Utilities HINTS ${CMAKE_INSTALL_PREFIX}/lib/RobotUtilities)

# your executable
add_executable(force_control_demo src/main.cc)
target_link_libraries(force_control_demo
  ${RUT}
  ${FORCE_CONTROLLERS}
)
```

## config example
Save the following as `config.yaml`:
``` yaml
admittance_controller:
  dt: 0.002
  log_to_file: false
  log_file_path: "/tmp/admittance_controller.log"
  alert_overrun: false
  compliance6d:
    stiffness: [100, 100, 100, 1, 1, 1]
    damping: [2, 2, 2, 0.2, 0.2, 0.2]
    inertia: [5, 5, 5, 0.005, 0.005, 0.005]
    stiction: [0, 0, 0, 0, 0, 0]
  max_spring_force_magnitude: 50
  max_spring_torque_magnitude: 4
  direct_force_control_gains:
    P_trans: 0
    I_trans: 0
    D_trans: 0
    P_rot: 0
    I_rot: 0
    D_rot: 0
  direct_force_control_I_limit: [0, 0, 0, 0, 0, 0]
```

## c++ code example
Headers:
``` c++
#include <RobotUtilities/spatial_utilities.h>
#include <force_control/admittance_controller.h>

typedef Eigen::Matrix<double, 6, 1> Vector6d;
```
Create the controller config, initialize controller:
``` c++
// load config
AdmittanceController::AdmittanceControllerConfig admittance_config;
const std::string CONFIG_PATH = "path_to/config.yaml";
YAML::Node config{};
try {
  config = YAML::LoadFile(CONFIG_PATH);
  deserialize(config["admittance_controller"], admittance_config);
} catch (const std::exception& e) {
  std::cerr << "Failed to load the config file: " << e.what() << std::endl;
  return -1;
}

AdmittanceController controller;

RUT::Timer timer;
RUT::TimePoint time0 = timer.tic();
RUT::Vector7d pose, pose_ref, pose_cmd;
RUT::Vector6d wrench, wrench_WTr;

controller.init(time0, admittance_config, pose);
```
Set force control axes and dimension. There are a couple options:
``` c++
// Regular admittance control, all 6 axes are force dimensions:
RUT::Matrix6d Tr = RUT::Matrix6d::Identity();
int n_af = 6;
controller.setForceControlledAxis(Tr, n_af);

// HFVC, compliant translational motion, rigid rotation motion 
RUT::Matrix6d Tr = RUT::Matrix6d::Identity();
int n_af = 3;
controller.setForceControlledAxis(Tr, n_af);

// HFVC, compliant rotational motion, rigid translational motion
RUT::Matrix6d Tr;
Tr << 0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 1,
    1, 0, 0, 0, 0, 0,
    0, 1, 0, 0, 0, 0,
    0, 0, 1, 0, 0, 0;
int n_af = 3;
controller.setForceControlledAxis(Tr, n_af);

// n_af = 0 disables compliance. All axes uses rigid motion
RUT::Matrix6d Tr = RUT::Matrix6d::Identity();
int n_af = 0;
controller.setForceControlledAxis(Tr, n_af);
```
Now we are ready to start the control loop. Assuming we have access to a `robot_ptr` object that can provides pose and wrench feedback.

``` c++
pose_ref = pose;
wrench_WTr.setZero();

timer.tic();

while (true) {
    // Update robot status
    robot_ptr->getCartesian(pose);
    robot_ptr->getWrenchTool(wrench);
    controller.setRobotStatus(pose, wrench);

    // Update robot reference
    controller.setRobotReference(pose_ref, wrench_WTr);

    // Compute the control output
    controller.step(pose_cmd);

    // send action to robot
    robot_ptr->setCartesian(pose_cmd);
    
    // sleep till next iteration
    spin();
}
```

## Reference
This package was implemented as a part of 
Y. Hou and M. T. Mason, "Robust Execution of Contact-Rich Motion Plans by Hybrid Force-Velocity Control,"
2019 International Conference on Robotics and Automation (ICRA), Montreal, QC, Canada, 2019, pp. 1933-1939

The implementation was initially based on James A. Maples and Joseph J. Becker, "Experience in Force Control of Robotic Manipulators", 
Then a lot more functionalities were added. Please contact yifan for questions.


================================================
FILE: CMakeLists.txt
================================================
cmake_minimum_required(VERSION 2.8.3)
project(force_control)

add_definitions(-std=c++17)

find_package(Eigen3 3.4 REQUIRED)
include_directories(${EIGEN3_INCLUDE_DIR})

include_directories(
  include
)

find_library(YAMLLib yaml-cpp HINTS /usr/local/lib)
find_library(RUT Utilities HINTS ${CMAKE_INSTALL_PREFIX}/lib/RobotUtilities)

add_library(FORCE_CONTROLLERS SHARED src/admittance_controller.cpp src/config_deserialize.cpp)
  target_link_libraries(FORCE_CONTROLLERS ${RUT} ${YAMLLib})

install(DIRECTORY include/
  DESTINATION ${CMAKE_INSTALL_PREFIX}/include/
)

install(TARGETS FORCE_CONTROLLERS
  DESTINATION ${CMAKE_INSTALL_PREFIX}/lib/
)


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 Yifan Hou@Stanford

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
FILE: .clang-format
================================================
# Google C/C++ Code Style settings
# https://clang.llvm.org/docs/ClangFormatStyleOptions.html
# Author: Kehan Xue, kehan.xue (at) gmail.com

Language: Cpp
BasedOnStyle: Google
AccessModifierOffset: -1
AlignAfterOpenBracket: Align
AlignConsecutiveAssignments: None
AlignOperands: Align
AllowAllArgumentsOnNextLine: true
AllowAllConstructorInitializersOnNextLine: true
AllowAllParametersOfDeclarationOnNextLine: false
AllowShortBlocksOnASingleLine: Empty
AllowShortCaseLabelsOnASingleLine: false
AllowShortFunctionsOnASingleLine: Inline
AllowShortIfStatementsOnASingleLine: Never  # To avoid conflict, set this "Never" and each "if statement" should include brace when coding
AllowShortLambdasOnASingleLine: Inline
AllowShortLoopsOnASingleLine: false
AlwaysBreakAfterReturnType: None
AlwaysBreakTemplateDeclarations: Yes
BinPackArguments: true
BreakBeforeBraces: Custom
BraceWrapping:
  AfterCaseLabel: false
  AfterClass: false
  AfterStruct: false
  AfterControlStatement: Never
  AfterEnum: false
  AfterFunction: false
  AfterNamespace: false
  AfterUnion: false
  AfterExternBlock: false
  BeforeCatch: false
  BeforeElse: false
  BeforeLambdaBody: false
  IndentBraces: false
  SplitEmptyFunction: false
  SplitEmptyRecord: false
  SplitEmptyNamespace: false
BreakBeforeBinaryOperators: None
BreakBeforeTernaryOperators: true
BreakConstructorInitializers: BeforeColon
BreakInheritanceList: BeforeColon
ColumnLimit: 80
CompactNamespaces: false
ContinuationIndentWidth: 4
Cpp11BracedListStyle: true
DerivePointerAlignment: false  # Make sure the * or & align on the left
EmptyLineBeforeAccessModifier: LogicalBlock
FixNamespaceComments: true
IncludeBlocks: Preserve
IndentCaseLabels: true
IndentPPDirectives: None
IndentWidth: 2
KeepEmptyLinesAtTheStartOfBlocks: true
MaxEmptyLinesToKeep: 1
NamespaceIndentation: None
ObjCSpaceAfterProperty: false
ObjCSpaceBeforeProtocolList: true
PointerAlignment: Left
ReflowComments: false
# SeparateDefinitionBlocks: Always   # Only support since clang-format 14
SpaceAfterCStyleCast: false
SpaceAfterLogicalNot: false
SpaceAfterTemplateKeyword: true
SpaceBeforeAssignmentOperators: true
SpaceBeforeCpp11BracedList: false
SpaceBeforeCtorInitializerColon: true
SpaceBeforeInheritanceColon: true
SpaceBeforeParens: ControlStatements
SpaceBeforeRangeBasedForLoopColon: true
SpaceBeforeSquareBrackets: false
SpaceInEmptyParentheses: false
SpacesBeforeTrailingComments: 2
SpacesInAngles: false
SpacesInCStyleCastParentheses: false
SpacesInContainerLiterals: false
SpacesInParentheses: false
SpacesInSquareBrackets: false
Standard: c++11
TabWidth: 4
UseTab: Never



================================================
FILE: include/force_control/admittance_controller.h
================================================
/*
This file is part of the package
https://github.com/yifan-hou/force_control

Reference: Y. Hou and M. T. Mason, "Robust Execution of Contact-Rich Motion Plans by Hybrid Force-Velocity Control,"
           2019 International Conference on Robotics and Automation (ICRA), Montreal, QC, Canada, 2019, pp. 1933-1939

The package is distributed under the following license:

MIT License

Copyright (c) [2024] [Yifan Hou]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#pragma once
#ifndef _ADMITTANCE_CONTROLLER_H_
#define _ADMITTANCE_CONTROLLER_H_

#include <RobotUtilities/spatial_utilities.h>
#include <RobotUtilities/timer_linux.h>

#include <Eigen/Geometry>
#include <chrono>
#include <deque>
#include <fstream>

class AdmittanceController {
 public:
  struct AdmittanceControllerConfig {
    double dt{0.002};  // used for integration/differentiation
    bool log_to_file{false};
    std::string log_file_path{""};
    bool alert_overrun{
        false};  // if true, print warning when step() takes too long

    struct ComplianceParameters6d {
      // Admittance parameters
      RUT::Matrix6d stiffness{};
      RUT::Matrix6d damping{};
      RUT::Matrix6d inertia{};
      RUT::Vector6d stiction{};  // static friction, eliminates drifting
    };
    ComplianceParameters6d compliance6d{};
    // spring force will be capped at this value.
    double max_spring_force_magnitude{0.0};
    double max_spring_torque_magnitude{0.0};

    struct PIDGains {
      double P_trans{0.0};
      double I_trans{0.0};
      double D_trans{0.0};

      double P_rot{0.0};
      double I_rot{0.0};
      double D_rot{0.0};
    };
    PIDGains direct_force_control_gains{};
    RUT::Vector6d direct_force_control_I_limit{};
  };

  AdmittanceController();
  ~AdmittanceController();
  AdmittanceController(AdmittanceController&&);

  /**
   * @brief      initialize the controller.
   *
   * @param[in]  time0         The time point to start ticking from.
   * @param[in]  config        The struct contains all configs.
   * @param[in]  pose_current  The current robot pose (tool frame)
   *
   * @return     True if successfully initialized.
   */
  bool init(const RUT::TimePoint& time0,
            const AdmittanceControllerConfig& config,
            const RUT::Vector7d& pose_current);

  /**
   * @brief      Sets the robot status.
   *
   * @param[in]  pose_WT    The current tool frame pose in the world frame.
   * @param[in]  wrench_WT  The tool wrench feedback.
   */
  void setRobotStatus(const RUT::Vector7d& pose_WT,
                      const RUT::Vector6d& wrench_T);
  /**
   * @brief      Set the position and force reference (user command).
   *
   * @param[in] pose_WT     tool pose represented in the world frame.
   * @param[in] wrench_WTr  wrench measured in the transformed frame.
   *
   * WARNING remember to call step() after setRobotReference, before
   * setForceControlledAxis. step() will properly update internal states, which
   * is required for setForceControlledAxis to work properly.
   */
  void setRobotReference(const RUT::Vector7d& pose_WT,
                         const RUT::Vector6d& wrench_WTr);
  /**
   * @brief      Sets the force controlled axis.
   *
   * @param[in]  Tr    6x6 orthonormal matrix. Describes the axis direction.
   * @param[in]  n_af  The number of force controlled axes.
   */
  void setForceControlledAxis(const RUT::Matrix6d& Tr, int n_af);

  /**
   * @brief      Sets the stiffness matrix.
   *
   * @param[in]  stiffness  The stiffness matrix.
   */
  void setStiffnessMatrix(const RUT::Matrix6d& stiffness);

  /**
   * @brief      Sets the damping matrix.
   *
   * @param[in]  damping  The damping matrix.
   */
  void setDampingMatrix(const RUT::Matrix6d& damping);

  /**
   * @brief return true if no error.
   */
  int step(RUT::Vector7d& pose);

  /**
   * @brief      Reset all internal states to default. It is recommended to call
   * reset() everytime the robot starts from a complete stop in the air. This
   * includes setting all position offsets/force errors to zero. Call reset()
   * when the next action is computed based on the robot's current pose instead
   *  of being part of a pre-planned trajectory. After a reset(), call
   * setRobotReference() immediately.
   */
  void reset();

  /**
   * @brief      Print the current states to the console.
   */
  void displayStates();

 private:
  struct Implementation;
  std::unique_ptr<Implementation> m_impl;
};

#endif  // _ADMITTANCE_CONTROLLER_H_



================================================
FILE: include/force_control/config_deserialize.h
================================================
#pragma once
#include <yaml-cpp/yaml.h>

template <typename T>
bool deserialize(const YAML::Node& node, T& config);


================================================
FILE: scripts/plot.py
================================================
import numpy as np

from plotly.offline import init_notebook_mode, iplot
from plotly.subplots import make_subplots
import plotly.graph_objs as go
import plotly.io as pio
import plotly.express as px

pio.templates.default = "plotly_dark"
pio.renderers.default = "browser"
# pio.renderers.default = "vscode"


# Load data from file
timestamp = []
pos_WTref = []
pos_WT = []
pos_WTadj = []
pos_WT_cmd = []
wrench_T_fb = []
wrench_Tr_All = []
with open(
    "/tmp/admittance_controller.log"
) as file_object:  # open file in a with statement
    for line in file_object:  # iterate line by line
        numbers = [
            float(e) for e in line.split()
        ]  # split line and convert string elements into int
        timestamp.append(numbers[0])
        pos_WTref.append(np.array(numbers[1:4]))
        pos_WT.append(np.array(numbers[4:7]))
        pos_WTadj.append(np.array(numbers[7:10]))
        pos_WT_cmd.append(np.array(numbers[10:13]))
        wrench_T_fb.append(np.array(numbers[13:19]))
        wrench_Tr_All.append(np.array(numbers[19:25]))

timestamp = np.array(timestamp)
pos_WTref = np.array(pos_WTref)
pos_WT = np.array(pos_WT)
pos_WTadj = np.array(pos_WTadj)
pos_WT_cmd = np.array(pos_WT_cmd)
wrench_T_fb = np.array(wrench_T_fb)
wrench_Tr_All = np.array(wrench_Tr_All)

fig = make_subplots(
    rows=9,
    cols=1,
    shared_xaxes="all",
    subplot_titles=("X", "Y", "Z", "w1", "w2", "w3", "w4", "w5", "w6"),
)
marker = dict(
    size=3,
    line=dict(width=1),
    opacity=0.5,
)
# fmt: off
fig.add_trace(go.Scatter(x=timestamp, y=pos_WTref[:,0], name='pos_WTref0'),row=1, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=pos_WTref[:,1], name='pos_WTref1'),row=2, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=pos_WTref[:,2], name='pos_WTref2'),row=3, col=1)

fig.add_trace(go.Scatter(x=timestamp, y=pos_WT[:,0], name='pos_WT0'),row=1, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=pos_WT[:,1], name='pos_WT1'),row=2, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=pos_WT[:,2], name='pos_WT2'),row=3, col=1)

fig.add_trace(go.Scatter(x=timestamp, y=pos_WTadj[:,0], name='pos_WTadj0'),row=1, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=pos_WTadj[:,1], name='pos_WTadj1'),row=2, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=pos_WTadj[:,2], name='pos_WTadj2'),row=3, col=1)

fig.add_trace(go.Scatter(x=timestamp, y=pos_WT_cmd[:,0], name='pos_WT_cmd0'),row=1, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=pos_WT_cmd[:,1], name='pos_WT_cmd1'),row=2, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=pos_WT_cmd[:,2], name='pos_WT_cmd2'),row=3, col=1)


fig.add_trace(go.Scatter(x=timestamp, y=wrench_T_fb[:,0], name='wrench_T_fb0'),row=4, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=wrench_T_fb[:,1], name='wrench_T_fb1'),row=5, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=wrench_T_fb[:,2], name='wrench_T_fb2'),row=6, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=wrench_T_fb[:,3], name='wrench_T_fb3'),row=7, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=wrench_T_fb[:,4], name='wrench_T_fb4'),row=8, col=1)
fig.add_trace(go.Scatter(x=timestamp, y=wrench_T_fb[:,5], name='wrench_T_fb5'),row=9, col=1)

# fmt: on
fig.update_layout(height=1200, width=800, title_text="Force Control")
fig.update_layout(hovermode="x unified")

fig.show()



================================================
FILE: src/admittance_controller.cpp
================================================
/*
This file is part of the package
https://github.com/yifan-hou/force_control

Reference: Y. Hou and M. T. Mason, "Robust Execution of Contact-Rich Motion Plans by Hybrid Force-Velocity Control,"
           2019 International Conference on Robotics and Automation (ICRA), Montreal, QC, Canada, 2019, pp. 1933-1939

The package is distributed under the following license:

MIT License

Copyright (c) [2024] [Yifan Hou]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

#include <RobotUtilities/spatial_utilities.h>
#include <RobotUtilities/timer_linux.h>
#include <force_control/admittance_controller.h>

#include <Eigen/QR>
#include <cmath>
#include <iostream>
#include <string>

using RUT::Matrix4d;
using RUT::Matrix6d;
using RUT::MatrixXd;
using RUT::Vector6d;

Eigen::IOFormat MatlabFmt(Eigen::StreamPrecision, 0, ", ", ";\n", "", "", "[",
                          "]");

struct AdmittanceController::Implementation {
  Implementation();
  ~Implementation();
  bool initialize(
      const RUT::TimePoint& time_initial_0,
      const AdmittanceControllerConfig& admittance_controller_config);

  void setRobotStatus(const RUT::Vector7d& pose_WT,
                      const RUT::Vector6d& wrench_WT);
  void setRobotReference(const RUT::Vector7d& pose_WT,
                         const RUT::Vector6d& wrench_WTr);
  void setForceControlledAxis(const Matrix6d& Tr_new, int n_af);
  void setStiffnessMatrix(const Matrix6d& stiffness);
  void setDampingMatrix(const Matrix6d& damping);
  int step(RUT::Vector7d& pose_to_send);
  void reset();
  void logStates();
  void displayStates();

  AdmittanceControllerConfig config{};

  // internal controller states
  Matrix6d Tr{};
  Matrix6d Tr_inv{};
  Vector6d v_force_selection{};
  Vector6d v_velocity_selection{};
  Matrix6d diag_force_selection{};
  Matrix6d diag_velocity_selection{};
  Matrix6d m_anni{};

  Matrix4d SE3_WTref{};
  Matrix4d SE3_WT{};
  Matrix4d SE3_TrefTadj{};
  Matrix4d SE3_WTadj{};
  Matrix4d SE3_TTadj{};
  Matrix4d SE3_WT_cmd{};
  Vector6d spt_TTadj{};
  Vector6d spt_TTadj_new{};
  Matrix6d Adj_WT{};
  Matrix6d Adj_TW{};
  Matrix6d Jac_v_spt{};
  Matrix6d Jac_v_spt_inv{};

  Vector6d v_spatial_WT{};
  Vector6d v_body_WT{};
  Vector6d v_body_WT_ref{};
  Vector6d v_Tr{};
  Vector6d vd_Tr{};
  Vector6d wrench_T_Err_prev{};
  Vector6d wrench_T_Err_I{};

  Vector6d wrench_T_fb{};  // force feedback measured in tool frame
  Vector6d wrench_Tr_cmd{};
  Vector6d wrench_T_spring{};
  Vector6d wrench_Tr_spring{};
  Vector6d wrench_Tr_fb{};
  Vector6d wrench_T_cmd{};
  Vector6d wrench_T_Err{};
  Vector6d wrench_T_PID{};
  Vector6d wrench_Tr_PID{};
  Vector6d wrench_Tr_Err{};
  Vector6d wrench_Tr_damping{};
  Vector6d wrench_Tr_All{};

  // misc
  RUT::Timer timer{};
  RUT::Profiler profiler{};
  std::ofstream log_file{};
};

AdmittanceController::Implementation::Implementation() {}

AdmittanceController::Implementation::~Implementation() {
  if (config.log_to_file)
    log_file.close();
}

bool AdmittanceController::Implementation::initialize(
    const RUT::TimePoint& time_initial_0,
    const AdmittanceControllerConfig& admittance_controller_config) {
  std::cout << "[AdmittanceController] Begin initialization.\n";
  config = admittance_controller_config;
  timer.tic(time_initial_0);

  reset();

  if (config.log_to_file) {
    log_file.open(config.log_file_path);
    if (log_file.is_open())
      std::cout << "[AdmittanceController] log file opened successfully at "
                << config.log_file_path << std::endl;
    else
      std::cerr << "[AdmittanceController] Failed to open log file at "
                << config.log_file_path << std::endl;
  }
  return true;
}

void AdmittanceController::Implementation::setRobotStatus(
    const RUT::Vector7d& pose_WT, const RUT::Vector6d& wrench_WT) {
  SE3_WT = RUT::pose2SE3(pose_WT);
  wrench_T_fb = -wrench_WT;
}

void AdmittanceController::Implementation::setRobotReference(
    const RUT::Vector7d& pose_WT, const RUT::Vector6d& wrench_WTr) {
  SE3_WTref = RUT::pose2SE3(pose_WT);
  wrench_Tr_cmd = wrench_WTr;
}

// After axis update, the goal pose with offset should be equal to current pose
// in the new velocity controlled axes. To satisfy this requirement, we need to
// change SE3_TrefTadj accordingly
void AdmittanceController::Implementation::setForceControlledAxis(
    const Matrix6d& Tr_new, int n_af) {
  v_force_selection = Vector6d::Zero();
  v_velocity_selection = Vector6d::Ones();
  for (int i = 0; i < n_af; ++i) {
    v_force_selection(i) = 1;
    v_velocity_selection(i) = 0;
  }
  diag_force_selection = v_force_selection.asDiagonal();
  diag_velocity_selection = v_velocity_selection.asDiagonal();

  m_anni = diag_velocity_selection * Tr * Jac_v_spt;
  spt_TTadj_new =
      (Matrix6d::Identity() - RUT::pseudoInverse(m_anni, 1e-6) * m_anni) *
      spt_TTadj;
  SE3_TrefTadj = SE3_WT * RUT::spt2SE3(spt_TTadj_new) * RUT::SE3Inv(SE3_WTref);

  // project these into force space
  wrench_T_Err_I = Tr_inv * diag_force_selection * Tr * wrench_T_Err_I;
  wrench_T_Err_prev = Tr_inv * diag_force_selection * Tr * wrench_T_Err_prev;

  Tr = Tr_new;
  Tr_inv = Tr.inverse();

  if (std::isnan(SE3_TrefTadj(0, 0))) {
    std::cerr << "\nThe computed offset has NaN." << std::endl;
    std::cerr << "SE3_WT:\n" << SE3_WT.format(MatlabFmt) << std::endl;
    std::cerr << "SE3_TTadj:\n" << SE3_TTadj.format(MatlabFmt) << std::endl;
    std::cerr << "spt_TTadj:\n" << spt_TTadj.format(MatlabFmt) << std::endl;
    std::cerr << "Jac_v_spt_inv:\n"
              << Jac_v_spt_inv.format(MatlabFmt) << std::endl;
    std::cerr << "Jac_v_spt:\n" << Jac_v_spt.format(MatlabFmt) << std::endl;
    std::cerr << "m_anni:\n" << m_anni.format(MatlabFmt) << std::endl;
    std::cerr << "spt_TTadj_new:\n"
              << spt_TTadj_new.format(MatlabFmt) << std::endl;
    std::cerr << "SE3_TrefTadj:\n"
              << SE3_TrefTadj.format(MatlabFmt) << std::endl;
    std::cerr << "\nNow paused at setForceControlledAxis()";
    getchar();
  }
}

void AdmittanceController::Implementation::setStiffnessMatrix(
    const Matrix6d& stiffness) {
  config.compliance6d.stiffness = stiffness;
}

void AdmittanceController::Implementation::setDampingMatrix(
    const Matrix6d& damping) {
  config.compliance6d.damping = damping;
}

// clang-format off
/*
 *
    force control law
        Frames:
            W: world frame
            T: current tool frame
            Tr: transformed genepose_currentralized space
        Frame suffixes
            fb: feedback (default, often omitted)
            ref: user provided reference, target
            adj: offset adjusted (command tool frame)
            cmd: output command, to be sent to the robot
        Quantities:
            SE3: 4x4 homogeneous coordinates
            se3: 6x1 twist coordinate of SE3
            spt: 6x1 special twist: 3x1 position, 3x1 exponential coordinate for rotation
            v: 6x1 velocity measured in an inertia frame.
              v_body: body velocity.
              v_spatial: spatial velocity.
            wrench: 6x1 wrench. Makes work with body velocity
            Jac_v_spt: 6x6 jacobian from body velocity to spt:
                Jac_v_spt * body velocity = spt time derivative
            Tr: 6x6 transformation matrix. Describes the force-velocity decomposition
 *
 */
// clang-format on
int AdmittanceController::Implementation::step(RUT::Vector7d& pose_to_send) {
  profiler.clear();
  profiler.start();
  timer.tic();
  // ----------------------------------------
  //  Compute Forces in Generalized space
  // ----------------------------------------
  /* Position updates */
  SE3_WTadj = SE3_WTref * SE3_TrefTadj;
  SE3_TTadj = RUT::SE3Inv(SE3_WT) * SE3_WTadj;  // aka SE3_S_err
  spt_TTadj = RUT::SE32spt(SE3_TTadj);

  Jac_v_spt_inv = RUT::JacobianSpt2BodyV(SE3_WT.block<3, 3>(0, 0));
  Jac_v_spt = Jac_v_spt_inv.inverse();

  Adj_WT = RUT::SE32Adj(SE3_WT);
  Adj_TW = RUT::SE32Adj(RUT::SE3Inv(SE3_WT));

  /* Velocity updates */
  v_body_WT = Adj_TW * v_spatial_WT;
  v_Tr = Tr * v_body_WT;

  /* Wrench updates */
  wrench_T_spring = Jac_v_spt * config.compliance6d.stiffness * spt_TTadj;
  profiler.stop("1");
  profiler.start();

  // clip spring force
  if (config.max_spring_force_magnitude > 0) {
    double spring_force_magnitude = wrench_T_spring.head<3>().norm();
    if (spring_force_magnitude > config.max_spring_force_magnitude) {
      wrench_T_spring.head<3>() *=
          config.max_spring_force_magnitude / spring_force_magnitude;
    }
  }
  if (config.max_spring_torque_magnitude > 0) {
    double spring_torque_magnitude = wrench_T_spring.tail<3>().norm();
    if (spring_torque_magnitude > config.max_spring_torque_magnitude) {
      wrench_T_spring.tail<3>() *=
          config.max_spring_torque_magnitude / spring_torque_magnitude;
    }
  }

  wrench_Tr_spring = Tr * wrench_T_spring;

  /* Force error, PID force control */
  wrench_T_cmd = Tr_inv * wrench_Tr_cmd;
  wrench_T_Err = wrench_T_cmd - wrench_T_fb;
  wrench_T_Err_I += wrench_T_Err;
  RUT::truncate6d(&wrench_T_Err_I, -config.direct_force_control_I_limit,
                  config.direct_force_control_I_limit);

  wrench_T_PID.head(3) =
      config.direct_force_control_gains.P_trans * wrench_T_Err.head(3) +
      config.direct_force_control_gains.I_trans * wrench_T_Err_I.head(3) +
      config.direct_force_control_gains.D_trans *
          (wrench_T_Err.head(3) - wrench_T_Err_prev.head(3));
  wrench_T_PID.tail(3) =
      config.direct_force_control_gains.P_rot * wrench_T_Err.tail(3) +
      config.direct_force_control_gains.I_rot * wrench_T_Err_I.tail(3) +
      config.direct_force_control_gains.D_rot *
          (wrench_T_Err.tail(3) - wrench_T_Err_prev.tail(3));
  wrench_Tr_PID = Tr * wrench_T_PID;
  wrench_T_Err_prev = wrench_T_Err;
  wrench_Tr_Err = Tr * wrench_T_Err;

  /* Apply static friction */
  for (int i = 0; i < 6; ++i) {
    if (std::abs(wrench_Tr_Err(i)) < config.compliance6d.stiction(i)) {
      wrench_Tr_Err(i) = 0;
    }
  }

  wrench_Tr_damping = -Tr * config.compliance6d.damping * v_body_WT;

  wrench_Tr_All = diag_force_selection * (wrench_Tr_spring + wrench_Tr_Err +
                                          wrench_Tr_PID + wrench_Tr_damping);
  profiler.stop("2");
  profiler.start();
  // ----------------------------------------
  //  force to velocity
  // ----------------------------------------

  /* Newton's Law */
  //  Axes are no longer independent when we take
  //      rotation in to consideration.
  //  Newton's Law in body (Tool) frame:
  //      W=M*vd
  //          W: body wrench
  //          M: Inertia matrix in body frame
  //          vd: body velocity time derivative
  //  Newton's law in transformed space
  //      TW=TMTinv Tvd
  //      W_Tr = TMTinv vd_Tr
  vd_Tr = (Tr * config.compliance6d.inertia * Tr_inv)
              .fullPivLu()
              .solve(wrench_Tr_All);

  // Velocity in the force-controlled direction: integrate acc computed from
  // Newton's law
  v_Tr += config.dt * vd_Tr;
  v_Tr = diag_force_selection *
         v_Tr;  // clean up velocity in the velocity-controlled direction

  // Velocity in the velocity-controlled direction: derive from reference pose
  v_body_WT_ref = Jac_v_spt_inv * spt_TTadj /
                  config.dt;  // reference velocity, derived from reference pose
  v_Tr += diag_velocity_selection * Tr * v_body_WT_ref;

  v_spatial_WT = Adj_WT * Tr_inv * v_Tr;
  profiler.stop("3");
  profiler.start();
  // ----------------------------------------
  //  velocity to pose
  // ----------------------------------------
  SE3_WT_cmd = SE3_WT + RUT::wedge6(v_spatial_WT) * SE3_WT * config.dt;
  RUT::SE32Pose(SE3_WT_cmd, pose_to_send);

  if (std::isnan(pose_to_send[0])) {
    std::cerr << "==================== pose is nan. =====================\n";
    displayStates();
    std::cerr << "Press ENTER to continue..." << std::endl;
    getchar();
    return false;
  }
  profiler.stop("4");
  profiler.start();
  if (config.log_to_file) {
    logStates();
  }
  profiler.stop("5");
  double timenow = timer.toc_ms();
  if (config.alert_overrun && timenow > config.dt * 1000.) {
    std::cerr << "AdmittanceController: step took too long: " << timenow << "ms"
              << std::endl;
    std::cerr << "Profiler: " << std::endl;
    profiler.show();
  }

  return true;
}

void AdmittanceController::Implementation::reset() {
  Tr = Matrix6d::Identity();
  Tr_inv = Matrix6d::Identity();
  v_force_selection = Vector6d::Zero();
  v_velocity_selection = Vector6d::Ones();
  diag_force_selection = Matrix6d::Zero();
  diag_velocity_selection = Matrix6d::Identity();
  m_anni = Matrix6d::Identity();

  SE3_WTref = Matrix4d::Identity();
  SE3_WT = Matrix4d::Identity();
  SE3_TrefTadj = Matrix4d::Identity();
  SE3_WTadj = Matrix4d::Identity();
  SE3_TTadj = Matrix4d::Identity();
  SE3_WT_cmd = Matrix4d::Identity();
  spt_TTadj = Vector6d::Zero();
  spt_TTadj_new = Vector6d::Zero();
  Adj_WT = Matrix6d::Identity();
  Adj_TW = Matrix6d::Identity();
  Jac_v_spt = Matrix6d::Identity();
  Jac_v_spt_inv = Matrix6d::Identity();

  v_spatial_WT = Vector6d::Zero();
  v_body_WT = Vector6d::Zero();
  v_body_WT_ref = Vector6d::Zero();
  v_Tr = Vector6d::Zero();
  vd_Tr = Vector6d::Zero();
  wrench_T_Err_prev = Vector6d::Zero();
  wrench_T_Err_I = Vector6d::Zero();

  wrench_T_fb = Vector6d::Zero();
  wrench_Tr_cmd = Vector6d::Zero();
  wrench_T_spring = Vector6d::Zero();
  wrench_Tr_spring = Vector6d::Zero();
  wrench_Tr_fb = Vector6d::Zero();
  wrench_T_cmd = Vector6d::Zero();
  wrench_T_Err = Vector6d::Zero();
  wrench_T_PID = Vector6d::Zero();
  wrench_Tr_PID = Vector6d::Zero();
  wrench_Tr_Err = Vector6d::Zero();
  wrench_Tr_damping = Vector6d::Zero();
  wrench_Tr_All = Vector6d::Zero();
}

void AdmittanceController::Implementation::logStates() {
  log_file << timer.toc_ms() << " ";
  RUT::stream_array_in(log_file, SE3_WTref.block<3, 1>(0, 3), 3);
  RUT::stream_array_in(log_file, SE3_WT.block<3, 1>(0, 3), 3);
  RUT::stream_array_in(log_file, SE3_WTadj.block<3, 1>(0, 3), 3);
  RUT::stream_array_in(log_file, SE3_WT_cmd.block<3, 1>(0, 3), 3);
  RUT::stream_array_in6d(log_file, wrench_T_fb);
  RUT::stream_array_in6d(log_file, wrench_Tr_All);

  // SE3_TrefTadj = Matrix4d::Identity();
  // SE3_TTadj = Matrix4d::Identity();
  // spt_TTadj = Vector6d::Zero();
  // spt_TTadj_new = Vector6d::Zero();
  // Adj_WT = Matrix6d::Identity();
  // Adj_TW = Matrix6d::Identity();
  // Jac_v_spt = Matrix6d::Identity();
  // Jac_v_spt_inv = Matrix6d::Identity();

  // v_spatial_WT = Vector6d::Zero();
  // v_body_WT = Vector6d::Zero();
  // v_body_WT_ref = Vector6d::Zero();
  // v_Tr = Vector6d::Zero();
  // vd_Tr = Vector6d::Zero();
  // wrench_T_Err_prev = Vector6d::Zero();
  // wrench_T_Err_I = Vector6d::Zero();

  // wrench_T_fb = Vector6d::Zero();
  // wrench_Tr_cmd = Vector6d::Zero();
  // wrench_T_spring = Vector6d::Zero();
  // wrench_Tr_spring = Vector6d::Zero();
  // wrench_Tr_fb = Vector6d::Zero();
  // wrench_T_cmd = Vector6d::Zero();
  // wrench_T_Err = Vector6d::Zero();
  // wrench_T_PID = Vector6d::Zero();
  // wrench_Tr_PID = Vector6d::Zero();
  // wrench_Tr_Err = Vector6d::Zero();
  // wrench_Tr_damping = Vector6d::Zero();
  // wrench_Tr_All = Vector6d::Zero();

  log_file << std::endl;
}

void AdmittanceController::Implementation::displayStates() {
  std::cout << "================= Parameters ================== " << std::endl;
  std::cout << "dt: " << config.dt << std::endl;
  std::cout << "log_to_file: " << config.log_to_file << std::endl;
  std::cout << "log_file_path: " << config.log_file_path << std::endl;
  std::cout << "compliance6d.stiffness: "
            << config.compliance6d.stiffness.format(MatlabFmt) << std::endl;
  std::cout << "compliance6d.damping: "
            << config.compliance6d.damping.format(MatlabFmt) << std::endl;
  std::cout << "compliance6d.inertia: "
            << config.compliance6d.inertia.format(MatlabFmt) << std::endl;
  std::cout << "direct_force_control_gains.P_trans: "
            << config.direct_force_control_gains.P_trans << std::endl;
  std::cout << "direct_force_control_gains.I_trans: "
            << config.direct_force_control_gains.I_trans << std::endl;
  std::cout << "direct_force_control_gains.D_trans: "
            << config.direct_force_control_gains.D_trans << std::endl;
  std::cout << "direct_force_control_gains.P_rot: "
            << config.direct_force_control_gains.P_rot << std::endl;
  std::cout << "direct_force_control_gains.I_rot: "
            << config.direct_force_control_gains.I_rot << std::endl;
  std::cout << "direct_force_control_gains.D_rot: "
            << config.direct_force_control_gains.D_rot << std::endl;
  std::cout << "direct_force_control_I_limit: "
            << config.direct_force_control_I_limit.format(MatlabFmt)
            << std::endl;
  std::cout << "================= Internal states ================== "
            << std::endl;
  std::cout << "Tr: " << Tr.format(MatlabFmt) << std::endl;
  std::cout << "Tr_inv: " << Tr_inv.format(MatlabFmt) << std::endl;
  std::cout << "v_force_selection: " << v_force_selection.format(MatlabFmt)
            << std::endl;
  std::cout << "v_velocity_selection: "
            << v_velocity_selection.format(MatlabFmt) << std::endl;
  std::cout << "diag_force_selection: "
            << diag_force_selection.format(MatlabFmt) << std::endl;
  std::cout << "diag_velocity_selection: "
            << diag_velocity_selection.format(MatlabFmt) << std::endl;
  std::cout << "m_anni: " << m_anni.format(MatlabFmt) << std::endl;
  std::cout << "SE3_WTref: " << SE3_WTref.format(MatlabFmt) << std::endl;
  std::cout << "SE3_WT: " << SE3_WT.format(MatlabFmt) << std::endl;
  std::cout << "SE3_TrefTadj: " << SE3_TrefTadj.format(MatlabFmt) << std::endl;
  std::cout << "SE3_WTadj: " << SE3_WTadj.format(MatlabFmt) << std::endl;
  std::cout << "SE3_TTadj: " << SE3_TTadj.format(MatlabFmt) << std::endl;
  std::cout << "SE3_WT_cmd: " << SE3_WT_cmd.format(MatlabFmt) << std::endl;
  std::cout << "spt_TTadj: " << spt_TTadj.format(MatlabFmt) << std::endl;
  std::cout << "spt_TTadj_new: " << spt_TTadj_new.format(MatlabFmt)
            << std::endl;
  std::cout << "Adj_WT: " << Adj_WT.format(MatlabFmt) << std::endl;
  std::cout << "Adj_TW: " << Adj_TW.format(MatlabFmt) << std::endl;
  std::cout << "Jac_v_spt: " << Jac_v_spt.format(MatlabFmt) << std::endl;
  std::cout << "Jac_v_spt_inv: " << Jac_v_spt_inv.format(MatlabFmt)
            << std::endl;
  std::cout << "v_spatial_WT: " << v_spatial_WT.format(MatlabFmt) << std::endl;
  std::cout << "v_body_WT: " << v_body_WT.format(MatlabFmt) << std::endl;
  std::cout << "v_body_WT_ref: " << v_body_WT_ref.format(MatlabFmt)
            << std::endl;
  std::cout << "v_Tr: " << v_Tr.format(MatlabFmt) << std::endl;
  std::cout << "vd_Tr: " << vd_Tr.format(MatlabFmt) << std::endl;
  std::cout << "wrench_T_Err_prev: " << wrench_T_Err_prev.format(MatlabFmt)
            << std::endl;
  std::cout << "wrench_T_Err_I: " << wrench_T_Err_I.format(MatlabFmt)
            << std::endl;
  std::cout << "wrench_T_fb: " << wrench_T_fb.format(MatlabFmt) << std::endl;
  std::cout << "wrench_Tr_cmd: " << wrench_Tr_cmd.format(MatlabFmt)
            << std::endl;
  std::cout << "wrench_T_spring: " << wrench_T_spring.format(MatlabFmt)
            << std::endl;
  std::cout << "wrench_Tr_spring: " << wrench_Tr_spring.format(MatlabFmt)
            << std::endl;
  std::cout << "wrench_Tr_fb: " << wrench_Tr_fb.format(MatlabFmt) << std::endl;
  std::cout << "wrench_T_cmd: " << wrench_T_cmd.format(MatlabFmt) << std::endl;
  std::cout << "wrench_T_Err: " << wrench_T_Err.format(MatlabFmt) << std::endl;
  std::cout << "wrench_T_PID: " << wrench_T_PID.format(MatlabFmt) << std::endl;
  std::cout << "wrench_Tr_PID: " << wrench_Tr_PID.format(MatlabFmt)
            << std::endl;
  std::cout << "wrench_Tr_Err: " << wrench_Tr_Err.format(MatlabFmt)
            << std::endl;
  std::cout << "wrench_Tr_damping: " << wrench_Tr_damping.format(MatlabFmt)
            << std::endl;
  std::cout << "wrench_Tr_All: " << wrench_Tr_All.format(MatlabFmt)
            << std::endl;
}

AdmittanceController::AdmittanceController()
    : m_impl{std::make_unique<Implementation>()} {}
AdmittanceController::~AdmittanceController() = default;
AdmittanceController::AdmittanceController(AdmittanceController&&) = default;

bool AdmittanceController::init(const RUT::TimePoint& time0,
                                const AdmittanceControllerConfig& config,
                                const RUT::Vector7d& pose_current) {
  m_impl->initialize(time0, config);

  setRobotStatus(pose_current, RUT::Vector6d::Zero());
  setRobotReference(pose_current, RUT::Vector6d::Zero());

  RUT::Vector7d pose_out;
  step(pose_out);
  setForceControlledAxis(Matrix6d::Identity(), 0);

  std::cout << "[AdmittanceController] initialization is done." << std::endl;
  return true;
}

void AdmittanceController::setRobotStatus(const RUT::Vector7d& pose_WT,
                                          const RUT::Vector6d& wrench_WT) {
  m_impl->setRobotStatus(pose_WT, wrench_WT);
}

void AdmittanceController::setRobotReference(const RUT::Vector7d& pose_WT,
                                             const RUT::Vector6d& wrench_WTr) {
  m_impl->setRobotReference(pose_WT, wrench_WTr);
}

void AdmittanceController::setForceControlledAxis(const Matrix6d& Tr_new,
                                                  int n_af) {
  m_impl->setForceControlledAxis(Tr_new, n_af);
}

void AdmittanceController::setStiffnessMatrix(const Matrix6d& stiffness) {
  m_impl->setStiffnessMatrix(stiffness);
}

void AdmittanceController::setDampingMatrix(const Matrix6d& damping) {
  m_impl->setDampingMatrix(damping);
}

int AdmittanceController::step(RUT::Vector7d& pose_to_send) {
  return m_impl->step(pose_to_send);
}

void AdmittanceController::displayStates() {
  m_impl->displayStates();
}


================================================
FILE: src/config_deserialize.cpp
================================================
#include "force_control/config_deserialize.h"
#include <RobotUtilities/spatial_utilities.h>

#include <yaml-cpp/yaml.h>

#include "force_control/admittance_controller.h"

template <>
bool deserialize(const YAML::Node& node,
                 AdmittanceController::AdmittanceControllerConfig& config) {
  try {
    config.dt = node["dt"].as<double>();
    config.log_to_file = node["log_to_file"].as<bool>();
    config.log_file_path = node["log_file_path"].as<std::string>();
    config.alert_overrun = node["alert_overrun"].as<bool>();
    config.compliance6d.stiffness = RUT::deserialize_vector<RUT::Vector6d>(
                                        node["compliance6d"]["stiffness"])
                                        .asDiagonal();
    config.compliance6d.damping =
        RUT::deserialize_vector<RUT::Vector6d>(node["compliance6d"]["damping"])
            .asDiagonal();
    config.compliance6d.inertia =
        RUT::deserialize_vector<RUT::Vector6d>(node["compliance6d"]["inertia"])
            .asDiagonal();
    config.compliance6d.stiction = RUT::deserialize_vector<RUT::Vector6d>(
        node["compliance6d"]["stiction"]);
    config.max_spring_force_magnitude =
        node["max_spring_force_magnitude"].as<double>();
    config.max_spring_torque_magnitude =
        node["max_spring_torque_magnitude"].as<double>();
    config.direct_force_control_gains.P_trans =
        node["direct_force_control_gains"]["P_trans"].as<double>();
    config.direct_force_control_gains.I_trans =
        node["direct_force_control_gains"]["I_trans"].as<double>();
    config.direct_force_control_gains.D_trans =
        node["direct_force_control_gains"]["D_trans"].as<double>();
    config.direct_force_control_gains.P_rot =
        node["direct_force_control_gains"]["P_rot"].as<double>();
    config.direct_force_control_gains.I_rot =
        node["direct_force_control_gains"]["I_rot"].as<double>();
    config.direct_force_control_gains.D_rot =
        node["direct_force_control_gains"]["D_rot"].as<double>();
    config.direct_force_control_I_limit =
        RUT::deserialize_vector<RUT::Vector6d>(
            node["direct_force_control_I_limit"]);
  } catch (const std::exception& e) {
    std::cerr << "Failed to load the config file: " << e.what() << std::endl;
    return false;
  }

  // validity check
  if (config.dt <= 0) {
    std::cerr << "Invalid dt: " << config.dt << std::endl;
    return false;
  }
  // diagonal elements of stiffness, damping, and inertia should be positive/non-negative
  if ((config.compliance6d.stiffness.diagonal().array() < 0).any()) {
    std::cerr << "Invalid compliance6d.stiffness: "
              << config.compliance6d.stiffness.diagonal().transpose()
              << ". All diagonal elements should be positive." << std::endl;
    return false;
  }
  if ((config.compliance6d.damping.diagonal().array() < 0).any()) {
    std::cerr << "Invalid compliance6d.damping: "
              << config.compliance6d.damping.diagonal().transpose()
              << ". All diagonal elements should be positive." << std::endl;
    return false;
  }
  if ((config.compliance6d.inertia.diagonal().array() <= 0).any()) {
    std::cerr << "Invalid compliance6d.inertia: "
              << config.compliance6d.inertia.diagonal().transpose()
              << ". All diagonal elements should be positive." << std::endl;
    return false;
  }
  // stiction should be non-negative
  if ((config.compliance6d.stiction.array() < 0).any()) {
    std::cerr << "Invalid compliance6d.stiction: "
              << config.compliance6d.stiction.transpose()
              << ". All elements should be non-negative." << std::endl;
    return false;
  }
  // direct force control gains should be non-negative
  if ((config.direct_force_control_gains.P_trans < 0) ||
      (config.direct_force_control_gains.I_trans < 0) ||
      (config.direct_force_control_gains.D_trans < 0) ||
      (config.direct_force_control_gains.P_rot < 0) ||
      (config.direct_force_control_gains.I_rot < 0) ||
      (config.direct_force_control_gains.D_rot < 0)) {
    std::cerr << "Invalid direct_force_control_gains. All elements should be "
                 "non-negative."
              << std::endl;
    return false;
  }

  // direct force control gains must be all zero if stiction is not zero.
  bool has_direct_force_control_gains =
      ((config.direct_force_control_gains.P_trans > 0) ||
       (config.direct_force_control_gains.I_trans > 0) ||
       (config.direct_force_control_gains.D_trans > 0) ||
       (config.direct_force_control_gains.P_rot > 0) ||
       (config.direct_force_control_gains.I_rot > 0) ||
       (config.direct_force_control_gains.D_rot > 0));
  if ((config.compliance6d.stiction.array() > 0).any() &&
      has_direct_force_control_gains) {
    std::cerr << "Invalid parameters. direct_force_control_gains must be all "
                 "zero if stiction is non-zero."
              << std::endl;
    return false;
  }

  return true;
}

