Directory structure:
└── yifan-hou-pub-icra19-hybrid-control/
    ├── README.md
    ├── LICENSE
    ├── algorithm/
    │   └── solvehfvc.m
    ├── examples/
    │   ├── block_tilting/
    │   │   ├── block_tilting_control.m
    │   │   ├── CodeGenWrapperBlockTilting.m
    │   │   └── symbolic_derivation_of_gradients_block_tilting.m
    │   ├── bottle_rotation/
    │   │   ├── bottle_rotation_control.m
    │   │   └── symbolic_derivation_of_gradients_bottle_rotation.m
    │   └── flip_against_corner/
    │       ├── flip_against_corner_control.m
    │       └── symbolic_derivation_of_gradients_flip_against_corner.m
    └── experiments/
        ├── cleanstart.m
        ├── interface.fig
        └── interface.m

================================================
FILE: README.md
================================================
# Robust Execution using Hybrid Force-velocity Control
A package for computing hybrid force-velocity control actions to execute a contact-rich motion plan robustly.

**Reference**

Yifan Hou, and Matthew T. Mason, " Robust Execution of Contact-Rich Motion Plans by Hybrid Force-Velocity Control“, IEEE International Conference on Robotics and Automation (ICRA) 2019, To appear.

## Contents
* */algorithm/solvehfvc.m* Implementation of the algorithm.
* */examples/* Three examples of contact-rich manipulation problems.



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2018 Yifan Hou@MLab

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: algorithm/solvehfvc.m
================================================
% Solve for hybrid force-velocity control actions
%
% Input arguments
%   required:
%       Omega: matrix for mapping from generalized velocity to configuration
%               time derivatives: q_dot = Omega*v
%       Jac_phi_q_all: Jacobian of holonomic constraints w.r.t. configuration
%       G, b_G: Goal description, affine constraints on generalized velocity
%               G*v = b_G
%       F: External force vector. Same size as generalized force
%       Aeq, beq: Guard condition, Aeq*v = beq
%       A, b_A: Guard condition, A*v <= b_A
%       dims:
%           dims.Actualized: number of actualized dimensions
%           dims.UnActualized: number of unactualized dimensions
%           dims.SlidingFriction: number of sliding friction dimensions
%           dims.Lambda: number of reaction forces
%
%   optional:
%       num_seeds: number of random initializations to try when solving for
%               the velocity control
% Outputs
%   n_av: number, dimensionality of velocity controlled actions
%   n_af: number, dimensionality of force controlled actions
%   R_a: (n_av+n_af)x(n_av+n_af) matrix, the transformation that describes the
%           direction of velocity&force control actions
%   w_av: n_av x 1 vector, magnitudes of velocity controls
%   eta_af: n_af x 1 vector,  magnitudes of force controls


function [n_av, n_af, R_a, w_av, eta_af] = solvehfvc(Omega, ...
        Jac_phi_q_all, G, b_G, F, Aeq, beq, A, b_A, dims, varargin)

persistent para
if isempty(para)
    para = inputParser;
    validMatrix = @(x) isnumeric(x);
    validVector = @(x) isempty(x) || (isnumeric(x) && (size(x, 2) == 1));
    validStruct = @(x) isstruct(x);
    addRequired(para, 'Omega', validMatrix);
    addRequired(para, 'Jac_phi_q_all', validMatrix);
    addRequired(para, 'G', validMatrix);
    addRequired(para, 'b_G', validVector);
    addRequired(para, 'F', validVector);
    addRequired(para, 'Aeq', validMatrix);
    addRequired(para, 'beq', validVector);
    addRequired(para, 'A', validMatrix);
    addRequired(para, 'b_A', validVector);
    addRequired(para, 'dims', validStruct);
    addParameter(para, 'num_seeds', 1);
end

parse(para, Omega, Jac_phi_q_all, G, b_G, F, Aeq, beq, A, b_A, dims, varargin{:});

kNumSeeds = para.Results.num_seeds;

% constants
kDimActualized      = dims.Actualized;
kDimUnActualized    = dims.UnActualized;
kDimSlidingFriction = dims.SlidingFriction;
kDimLambda          = dims.Lambda;
kDimContactForce    = kDimLambda + kDimSlidingFriction;

Jac_phi_q = Jac_phi_q_all(1 : end - kDimSlidingFriction, :);
kDimGeneralized = kDimActualized + kDimUnActualized;
assert(kDimLambda == size(Jac_phi_q, 1));

disp('============================================================');
disp('          Begin solving for velocity commands               ');
disp('============================================================');
disp('-------    Determine Possible Dimension of Control   -------');

N = Jac_phi_q*Omega;
NG = [N; G];

rank_N = rank(N);
rank_NG = rank(NG);

n_av_min = rank_NG - rank_N;
% n_av_max = kDimGeneralized - rank_N;
n_av = n_av_min;
n_af = kDimActualized - n_av;
% b_NG = [zeros(size(N, 1), 1); b_G];
basis_NG = null(NG);
basis_c = null([basis_NG';
        eye(kDimUnActualized), zeros(kDimUnActualized,kDimActualized)]);

disp(['r_N + n_a: ', num2str(rank_N + kDimActualized)]);
disp(['n_v: ', num2str(kDimGeneralized)]);
assert(rank_N + kDimActualized > kDimGeneralized);

disp('-------  Solve for Directions  -------')
n_c = rank_NG - kDimUnActualized;

% Projected gradient descent
NIter   = 50;
basis_N = null(N);
BB      = basis_c'*basis_c;
NN      = basis_N*(basis_N');

cost_all = zeros(1, kNumSeeds);
k_all = rand([n_c, n_av, kNumSeeds]);
for seed = 1:kNumSeeds
    k  = k_all(:,:, seed);
    kn = normByCol(basis_c*k);
    k  = bsxfun(@rdivide, k, kn);

    for iter = 1:NIter
        % compute gradient
        g = zeros(n_c, n_av);
        costs = 0;
        for i = 1:n_av
            ki = k(:,i);
            for j = 1:n_av
                if i == j
                    continue;
                end
                kj = k(:,j);
                costs = costs + (ki'*BB*kj)^2;
                g(:, i) = g(:, i) + 2*(ki'*BB*kj)*BB*kj;
            end
            g(:, i) = g(:, i) - 2*(basis_c')*NN*basis_c*ki;
            costs   = costs - ki'*(basis_c')*NN*basis_c*ki;
        end
        % descent
        delta = 10;
        k     = k - delta*g;
        % project
        kn = normByCol(basis_c*k);
        k  = bsxfun(@rdivide, k, kn);
    end
    cost_all(seed) = costs;
    k_all(:,:,seed) = k;
    disp(['cost: ' num2str(costs)]);
end

[~, best_id] = min(cost_all);
k_best = k_all(:,:,best_id);
C_best = (basis_c*k_best)';

R_a = [null(C_best(:, kDimUnActualized+1:end))';
        C_best(:, kDimUnActualized+1:end)];
T = blkdiag(eye(kDimUnActualized), R_a);

b_NG = [zeros(size(N, 1), 1); b_G];
v_star = NG\b_NG;
w_av = C_best*v_star;


disp('============================================================');
disp('          Begin solving for force commands');
disp('============================================================');
% unactuated dimensions
H = [eye(kDimUnActualized), zeros(kDimUnActualized, kDimActualized)];
% Newton's laws
T_inv = T^-1;
M_newton = [zeros(kDimUnActualized, kDimContactForce) H*T_inv; ...
            T*(Omega')*(Jac_phi_q_all') eye(kDimGeneralized); ...
            Aeq];
b_newton = [zeros(size(H,1), 1); -T*F; beq];

M_free = M_newton(:, [1:kDimContactForce+kDimUnActualized, kDimContactForce+kDimUnActualized+n_af+1:end]);
M_eta_af = M_newton(:, [kDimContactForce+kDimUnActualized+1:kDimContactForce+kDimUnActualized+n_af]);

% prepare the QP
%   variables: [free_force, dual_free_force, eta_af]
n_free = kDimContactForce + kDimUnActualized + n_av;
n_dual_free = size(M_newton, 1);
% 0.5 x'Qx + f'x
qp.Q = diag([zeros(1, n_free + n_dual_free), ones(1, n_af)]);
qp.f = zeros(n_free + n_dual_free + n_af, 1);
% Ax<b
A_temp = [A(:, 1:kDimContactForce), A(:, kDimContactForce+1:end)*T_inv];
A_lambda_eta_u = A_temp(:, 1:kDimContactForce+kDimUnActualized);
A_eta_af = A_temp(:, kDimContactForce+kDimUnActualized+1:kDimContactForce+kDimUnActualized+n_af);
A_eta_av = A_temp(:, kDimContactForce+kDimUnActualized+n_af+1:end);

qp.A = [A_lambda_eta_u A_eta_av zeros(size(A, 1), n_dual_free) A_eta_af];
qp.b = b_A;
% Aeq = beq
qp.Aeq = [2*eye(n_free), M_free', zeros(n_free, n_af);
          M_free, zeros(size(M_free, 1)), M_eta_af];
qp.beq = [zeros(n_free, 1); b_newton];

options = optimoptions('quadprog', 'Display', 'final-detailed');
x = quadprog(qp.Q, qp.f, qp.A, qp.b, qp.Aeq, qp.beq, [], [], [],options);

disp('============================================================');
disp('                  Done.                                     ');
disp('============================================================');

% lambda = x(1:kDimLambda);
eta_af = x(n_free + n_dual_free + 1:end);

% hand_contact_force = lambda(1:2);
% table_contact_force = lambda([3 5]);
% binwall_contact_force = lambda([4 6]);


disp('World frame velocity:');
disp(R_a^-1*[zeros(n_af, 1); w_av]);

disp('World frame force:');
disp(R_a^-1*[eta_af; zeros(n_av, 1)]);


% disp('hand contact force: ');
% disp(hand_contact_force');
% disp('table contact force: ');
% disp(table_contact_force');
% disp('binwall contact force: ');
% disp(binwall_contact_force');

disp('Equality constraints violation:');
disp(sum(abs(qp.beq - qp.Aeq*x)));
disp('Inequality constraints b - Ax > 0 violation:');
b_Ax = qp.b - qp.A*x;
disp(sum(find(b_Ax < 0)));


end


================================================
FILE: examples/block_tilting/block_tilting_control.m
================================================
% function to solve the block tilting example.
% This file compute the Jacobians, Goal descriptions, external forces,
%   guard conditions, etc, so as to call solvehfvc.m
%

% states
%   [x_o, y_o, z_0, qw_o, qx_o, qy_o, qz_o, x_h, y_h, z_h]'
%
% If run with no input, default state is used.
% If run with state input, compute the controls at the given state.
% Outputs
%   n_av: number, dimensionality of velocity controlled actions
%   n_af: number, dimensionality of force controlled actions
%   R_a: (n_av+n_af)x(n_av+n_af) matrix, the transformation that describes the
%           direction of velocity&force control actions
%   w_av: n_av x 1 vector, magnitudes of velocity controls
%   eta_af: n_af x 1 vector,  magnitudes of force controls
function [n_av, n_af, R_a, w_av, eta_af] = block_tilting_control(inputs)
addpath ../../algorithm
addpath generated

% weight
kObjectMass = 0.5;
kHandMass = 0.3;
kGravityConstant = 9.8;

% friction
kFrictionCoefficientTable = 0.8;
kFrictionCoefficientHand = 0.8;
kFrictionConeSides = 6;  % polyhedron approximation of friction cone
v_friction_directions = zeros(3, kFrictionConeSides);
kMinNormalForce = 10; % Newton

% inputs
if nargin == 0
    kObjectEdgeLength = 0.075;
    p_WH = [0.4*kObjectEdgeLength, 0, kObjectEdgeLength]';
    kGoalVelocity = 0.5; % rad
    kTiltDirection = [1 0 0]';
    m_project = diag([1 0 1]);

    % initial poses
    p_WH0 = [0.4*kObjectEdgeLength, 0, kObjectEdgeLength]';
    p_WO0 = [kObjectEdgeLength/2, 0, 0]';
else
    p_WH = inputs.p_WH;

    kObjectEdgeLength = inputs.ObjectEdgeLength;
    kGoalVelocity     = inputs.kGoalRotationVelocity;
    kTiltDirection    = inputs.TiltDirection;
    m_project         = inputs.m_project;
    p_WH0             = inputs.p_WH0;
    p_WO0             = inputs.p_WO0;
end
kRotateAxis = cross([0 0 1]', kTiltDirection); % to the left
p_LineContact = p_WO0;
p_WO = p_WO0;
v_C2C0 = p_WH0 - p_LineContact;
q_WO = quatBTVec(m_project*v_C2C0, m_project*(p_WH - p_WO));

q = [p_WO; q_WO; p_WH];
disp('Input q: ');
disp(q);


for i = 1:kFrictionConeSides
    v_friction_directions(1, i) = sin(2*pi*i/kFrictionConeSides);
    v_friction_directions(2, i) = cos(2*pi*i/kFrictionConeSides);
end

p_OHC = p_WH0 - p_WO0;

% object pose
R_WO = quat2m(q_WO);
E_qO = 0.5*[-q_WO(2) -q_WO(3) -q_WO(4);
            q_WO(1) -q_WO(4) q_WO(3);
            q_WO(4) q_WO(1) -q_WO(2);
            -q_WO(3) q_WO(2) q_WO(1)];
Omega = blkdiag(R_WO, E_qO, eye(3));

% contact point with table
p_OTC_all = [kRotateAxis*kObjectEdgeLength/2, -kRotateAxis*kObjectEdgeLength/2];
p_WTC_all = R_WO*p_OTC_all + p_WO*[1, 1];

% goal twist
t_WG = [-cross(kRotateAxis, p_LineContact); kRotateAxis]*kGoalVelocity;
Adj_g_WO_inv = [R_WO', -R_WO'*wedge(p_WO); zeros(3), R_WO'];

t_OG = Adj_g_WO_inv*t_WG;

G = [eye(6) zeros(6, 3)    ];
b_G = t_OG;


% external force
F_WGO = [0 0 -kObjectMass*kGravityConstant]';
F_WGH = [0 0 -kHandMass*kGravityConstant]';
F = [R_WO'*F_WGO; zeros(3,1); F_WGH];

% Guard conditions
%   hand contact is sticking; (force is in world frame)
%   table contacts are sticking;
%   hand contact normal force lower bound
A = zeros(kFrictionConeSides*(1+2)+1, ...
        3*(1+2)+9);
z = [0 0 1]';
for i=1:kFrictionConeSides
    A(i, 1:3) = (v_friction_directions(:, i)' - kFrictionCoefficientHand*z')*(R_WO');
    A(kFrictionConeSides+i, 4:6) = ...
            v_friction_directions(:, i)' - kFrictionCoefficientTable*z';
    A(2*kFrictionConeSides+i, 7:9) = ...
            v_friction_directions(:, i)' - kFrictionCoefficientTable*z';
end
A(3*kFrictionConeSides + 1, 1:3) = -z'*(R_WO');
b_A = [zeros(kFrictionConeSides*(1+2), 1); -kMinNormalForce];

dims.Actualized      = 3;
dims.UnActualized    = 6;
dims.SlidingFriction = 0;
dims.Lambda          = 3*(1+2);

% Jacobian of Holonomic constraints
Jac_phi_q = jac_phi_q_block_tilting(p_WO, q_WO, p_WH, p_OHC, p_WTC_all, p_OTC_all);
tic
[n_av, n_af, R_a, w_av, eta_af] = solvehfvc(Omega, Jac_phi_q, ...
        G, b_G, F, [], [], A, b_A, dims, 'num_seeds', 3);
toc





================================================
FILE: examples/block_tilting/CodeGenWrapperBlockTilting.m
================================================
function [n_av, n_af, R_a, w_av, eta_af] = ...
        CodeGenWrapperBlockTilting(p_WO, q_WO, p_WH, p_OHC, p_WTC_all, p_OTC_all, Omega, G, b_G, F, A, b_A, dims)

% Jacobian of Holonomic constraints
Jac_phi_q = jac_phi_q_block_tilting(p_WO, q_WO, p_WH, p_OHC, p_WTC_all, p_OTC_all);

[n_av, n_af, R_a, w_av, eta_af] = solvehfvc(Omega, Jac_phi_q, ...
        G, b_G, F, [], [], A, b_A, dims, 'num_seeds', 1);
    


================================================
FILE: examples/block_tilting/symbolic_derivation_of_gradients_block_tilting.m
================================================
% Derive jacobian function for 'block tilting' example.

clear;clc;
% symbols
%   poses in world frame
p_WO     = sym('p_WO',[3,1],'real');  % object position
q_WO     = sym('q_WO',[4,1],'real');  % object quaternion
p_WH     = sym('p_WH',[3,1],'real');  % hand position

p_OHC = sym('p_OHC',[3,1],'real');  % hand contact in object frame

%   table contacts
p_WTC_all = sym('p_WTC_all',[3, 2],'real'); % in world frame
p_OTC_all = sym('p_OTC_all',[3, 2],'real'); % in object frame

holonomic_constraint = sym('Phi', [3*(1+2), 1], 'real');
% Hand contact
holonomic_constraint(1:3) = p_WH - (quatOnVec(p_OHC, q_WO)+p_WO);
% table contacts
holonomic_constraint(4:6) = quatOnVec(p_OTC_all(:,1), q_WO)+p_WO-p_WTC_all(:,1);
holonomic_constraint(7:9) = quatOnVec(p_OTC_all(:,2), q_WO)+p_WO-p_WTC_all(:,2);

holonomic_constraint = simplify(holonomic_constraint);

save generated/derivation.mat;
disp('Computing derivatives:');

%% ---------------------------------------------------------------
%           calculate derivatives
% ---------------------------------------------------------------
% load generated/derivation
deriv_q  = @(f) [
        diff(f,'p_WO1'), diff(f,'p_WO2'), diff(f,'p_WO3'), ...
        diff(f,'q_WO1'), diff(f,'q_WO2'), diff(f,'q_WO3'), diff(f, 'q_WO4'), ...
        diff(f,'p_WH1'), diff(f,'p_WH2'), diff(f,'p_WH3')];

Phi_q  = simplify(deriv_q(holonomic_constraint));
disp('Done. Generating file:');

%% ---------------------------------------------------------------
%           write to file
% ---------------------------------------------------------------
matlabFunction(Phi_q, 'File', 'generated/jac_phi_q_block_tilting', ...
        'vars', {p_WO, q_WO, p_WH, p_OHC, p_WTC_all, p_OTC_all});
save generated/derivation.mat;
disp('All done');



================================================
FILE: examples/bottle_rotation/bottle_rotation_control.m
================================================
% script to solve the bottle rotation example.
% This file compute the Jacobians, Goal descriptions, external forces,
%   guard conditions, etc, so as to call solvehfvc.m
%
% states
%   [x_o, y_o, z_0, qw_o, qx_o, qy_o, qz_o, x_h, y_h, z_h]'
%
% Outputs
%   n_av: number, dimensionality of velocity controlled actions
%   n_af: number, dimensionality of force controlled actions
%   R_a: (n_av+n_af)x(n_av+n_af) matrix, the transformation that describes the
%           direction of velocity&force control actions
%   w_av: n_av x 1 vector, magnitudes of velocity controls
%   eta_af: n_af x 1 vector,  magnitudes of force controls
function [n_av, n_af, R_a, w_av, eta_af] = bottle_rotation_control()
addpath ../../algorithm
addpath generated

% weight
kObjectMass = 1.0;
kHandMass = 2.0;
kGravityConstant = 9.8;

% geometry
kObjectRadius = 0.04;
kObjectLength = 0.2;

% friction
kFrictionCoefficientTable = 0.8;
kFrictionCoefficientHand = 1.2;
kPointsPerFaceContact = 4;  % contact points between object and hand
kFrictionConeSides = 6;  % polyhedron approximation of friction cone
v_friction_directions = zeros(3, kFrictionConeSides);
kMinNormalForce = 0.5; % Newton

% inputs
p_WH = [0 0 0.5]';
q_WH = aa2quat(0.2, [1 0 0]');
kGoalVelocity = 0.5; % rad

for i = 1:kFrictionConeSides
    v_friction_directions(1, i) = sin(2*pi*i/kFrictionConeSides);
    v_friction_directions(2, i) = cos(2*pi*i/kFrictionConeSides);
end
% origin of object frame is at the center of its bottom
% origin of gripper frame is at the center of palm flange surface
p_OHC_all = zeros(3, kPointsPerFaceContact);
for i = 1:kPointsPerFaceContact
    p_OHC_all(1, i) = kObjectRadius*sin(2*pi*i/kPointsPerFaceContact);
    p_OHC_all(2, i) = kObjectRadius*cos(2*pi*i/kPointsPerFaceContact);
    p_OHC_all(3, i) = kObjectLength;
end
p_HHC_all = p_OHC_all;
p_HHC_all(3, :) = 0;

% object pose
p_WO = p_WH - quatOnVec([0 0 1]', q_WH)*kObjectLength;
q_WO = q_WH;
q = [p_WO; q_WO; p_WH; q_WH];
disp('Input q: ');
disp(q);

R_WO = quat2m(q_WO);
R_WH = quat2m(q_WH);
E_qO = 0.5*[-q_WO(2) -q_WO(3) -q_WO(4);
			q_WO(1) -q_WO(4) q_WO(3);
			q_WO(4) q_WO(1) -q_WO(2);
			-q_WO(3) q_WO(2) q_WO(1)];
E_qH = 0.5*[-q_WH(2) -q_WH(3) -q_WH(4);
			q_WH(1) -q_WH(4) q_WH(3);
			q_WH(4) q_WH(1) -q_WH(2);
			-q_WH(3) q_WH(2) q_WH(1)];
Omega = blkdiag(R_WO, E_qO, R_WH, E_qH);

% contact point with table
p_Wtemp = quatOnVec([0 0 1]', q_WO);
p_Wtemp(3) = 0;
p_Otemp = R_WO'*p_Wtemp;
p_Otemp(3) = 0;
p_OTC = p_Otemp/norm(p_Otemp)*kObjectRadius; % table contact
p_WTC = R_WO*p_OTC + p_WO;
% p_WTC(3) = kTableZ;

% rotation axis on the table
v_WRotAxis = R_WO*p_Otemp;
v_WRotAxis(3) = 0;
v_WRotAxis = v_WRotAxis/norm(v_WRotAxis);

% goal twist
t_WG = [-cross(v_WRotAxis, p_WTC); v_WRotAxis]*kGoalVelocity;
Adj_g_WO_inv = [R_WO', -R_WO'*wedge(p_WO); zeros(3), R_WO'];

t_OG = Adj_g_WO_inv*t_WG;

G = [eye(6) zeros(6)];
b_G = t_OG;

% Holonomic constraints
Jac_phi_q = jac_phi_q_bottle_rotation(p_WO, q_WO, p_WH, q_WH, p_OTC, p_WTC, ...
        p_OHC_all, p_HHC_all);

% external force
F_WGO = [0 0 -kObjectMass*kGravityConstant]';
F_WGH = [0 0 -kHandMass*kGravityConstant]';
F = [R_WO'*F_WGO; zeros(3,1); R_WH'*F_WGH; zeros(3,1)];

% Guard Conditions
A = zeros(kFrictionConeSides*(1+kPointsPerFaceContact)+kPointsPerFaceContact, ...
        3*(1+kPointsPerFaceContact)+12);
z = [0 0 1]';
for i=1:kFrictionConeSides
    A(i, 1:3) = v_friction_directions(:, i)' - kFrictionCoefficientTable*z';
    for j=1:kPointsPerFaceContact
        A(j*kFrictionConeSides+i, j*3+1:j*3+3) = ...
                v_friction_directions(:, i)' - kFrictionCoefficientHand*z';
    end
end
for i = 1:kPointsPerFaceContact
    A(kFrictionConeSides*(1+kPointsPerFaceContact) + i, 3*i+1:3*i+3) = -z';
end
b_A = [zeros(kFrictionConeSides*(1+kPointsPerFaceContact), 1);
       -kMinNormalForce*ones(kPointsPerFaceContact, 1)];

dims.Actualized      = 6;
dims.UnActualized    = 6;
dims.SlidingFriction = 0;
dims.Lambda          = 3*(1+kPointsPerFaceContact);

[n_av, n_af, R_a, w_av, eta_af] = solvehfvc(Omega, Jac_phi_q, ...
        G, b_G, F, [], [], A, b_A, dims, 'num_seeds', 1);





================================================
FILE: examples/bottle_rotation/symbolic_derivation_of_gradients_bottle_rotation.m
================================================
% Derive jacobian function for 'flip against corner' example.

clear;clc;
% symbols
q_WO     = sym('q_WO',[4,1],'real');  % object in world frame
p_WO     = sym('p_WO',[3,1],'real');
q_WH     = sym('q_WH',[4,1],'real');  % hand in world frame
p_WH     = sym('p_WH',[3,1],'real');

p_OTC = sym('p_OTC',[3,1],'real');  % table contacts in object frame
p_WTC = sym('p_WTC',[3,1],'real');  % table contacts in world frame

% contacts between the object and the hand
kPointsPerFaceContact = 4;
p_OHC_all = sym('p_OHC_all',[3, kPointsPerFaceContact],'real');
p_HHC_all = sym('p_HHC_all',[3, kPointsPerFaceContact],'real');

holonomic_constraint = sym('Phi', [3*(1+kPointsPerFaceContact), 1], 'real');

% table contact
holonomic_constraint(1:3) = quatOnVec(p_OTC, q_WO) + p_WO - p_WTC;
% contact between the object and the hand
for i = 1:kPointsPerFaceContact
	holonomic_constraint(3*i+1:3*i+3) = ...
        quatOnVec(quatOnVec(p_OHC_all(:,i), q_WO)+p_WO-p_WH, quatInv(q_WH)) ...
			- p_HHC_all(:,i);
end

holonomic_constraint = simplify(holonomic_constraint);
save generated/derivation.mat;
disp('Computing derivatives:');

%% ---------------------------------------------------------------
% 			calculate derivatives
% ---------------------------------------------------------------
% load generated/derivation
deriv_q  = @(f) [
		diff(f,'p_WO1'), diff(f,'p_WO2'), diff(f,'p_WO3'), ...
		diff(f,'q_WO1'), diff(f,'q_WO2'), diff(f,'q_WO3'), diff(f, 'q_WO4'), ...
		diff(f,'p_WH1'), diff(f,'p_WH2'), diff(f,'p_WH3'), ...
		diff(f,'q_WH1'), diff(f,'q_WH2'), diff(f,'q_WH3'), diff(f, 'q_WH4')];

Phi_q  = simplify(deriv_q(holonomic_constraint));
disp('Done. Generating file:');

%% ---------------------------------------------------------------
% 			write to file
% ---------------------------------------------------------------
jac_phi_q  = matlabFunction(Phi_q, 'File', 'generated/jac_phi_q_bottle_rotation', 'vars', ...
	{p_WO, q_WO, p_WH, q_WH, p_OTC, p_WTC, p_OHC_all, p_HHC_all});
save generated/derivation.mat;
disp('All done');



================================================
FILE: examples/flip_against_corner/flip_against_corner_control.m
================================================
% function to solve the flip against corner example.
% This file compute the Jacobians, Goal descriptions, external forces,
%   guard conditions, etc, so as to call solvehfvc.m
%
% states
%   [y_o, z_0, theta_o, y_h, z_h]'
% choice of coordinate frames
%   see figure
% Goal is specified as the velocity of hand contact in z direction
%
% If run with no input, default state is used.
% If run with state input, compute the controls at the given state.
% Outputs
%   n_av: number, dimensionality of velocity controlled actions
%   n_af: number, dimensionality of force controlled actions
%   R_a: (n_av+n_af)x(n_av+n_af) matrix, the transformation that describes the
%           direction of velocity&force control actions
%   w_av: n_av x 1 vector, magnitudes of velocity controls
%   eta_af: n_af x 1 vector,  magnitudes of force controls
function [n_av, n_af, R_a, w_av, eta_af] = flip_against_corner_control(inputs)
addpath ../../algorithm
addpath generated

% how to cope with sliding friciton
% 1. separate jacobian for velocity and force. force has more entries for friction
% 2. Guard condition:
%       equality constraint on friction and normal force
%       normal force upper limit
% 3. for sliding friciton, friciton coefficient should use upper bound

% weight
kObjectMass = 0.12;
kHandMass = 0.0;
kGravityConstant = 9.8;

% friction
kFrictionCoefficientTable = 0.4; % upper bound to ensure sliding
kFrictionCoefficientHand = 0.7; % lower bound to ensure sticking
kFrictionCoefficientBin = 0.4; % upper bound to ensure sliding
kMinNormalForce = 5; % Newton
kMinNormalForceSliding = -5; % Newton
kMaxNormalForceSliding = 100; % Newton

% dimensions
kDimGeneralized = 5;
kDimUnActualized = 3;
kDimActualized = 2;
kDimLambda = 4;
kDimSlidingFriction = 2;

% inputs
if nargin == 0
    kObjectLength = 0.1;
    kObjectThickness = 0.02;
    kGoalRotationVelocity = 0.5; % rad
    % feedback
    p_WH = [kObjectLength, kObjectThickness/2]';

    % initial poses
    p_WH0 = [kObjectLength, kObjectThickness/2]';
    p_WO0 = [kObjectLength/2, kObjectThickness/2]';
else
    kObjectLength = inputs.kObjectLength;
    kObjectThickness = inputs.kObjectThickness;
    kGoalRotationVelocity = inputs.kGoalRotationVelocity; % rad
    % feedback
    p_WH = inputs.p_WH;

    % initial poses
    p_WH0 = inputs.p_WH0;
    p_WO0 = inputs.p_WO0;
end

% compute object pose
%   Ideally we should use perception; here we hack it by assuming the
%   contact between the hand and the object is sticking, and solve the object
%   pose from hand pose

% 1. Solve for theta
%   This is a a*sin(theta)+bsin(theta)=c problem
a = p_WH0(2) - p_WO0(2) + kObjectThickness/2;
b = kObjectLength;
c = p_WH(2) - p_WO0(2) + kObjectThickness/2;
phi = atan2(a, b);
theta_plus_phi = asin(c/norm([a, b]));
theta = theta_plus_phi - phi;
% 2. solve for z
l_diagonal = sqrt(kObjectThickness^2 + kObjectLength^2);
angle_inner_sharp = asin(kObjectThickness/l_diagonal);
p_temp = [kObjectThickness*sin(theta)+l_diagonal/2*cos(theta+angle_inner_sharp);
        l_diagonal/2*sin(theta+angle_inner_sharp)];
p_temp_w = p_WO0 - [kObjectLength/2; kObjectThickness/2];
p_WO = p_temp + p_temp_w;

R_WO = aa2mat(theta, [1 0 0]');
R_WO = R_WO(2:3, 2:3);

% Generalized velocity = q time derivative
% thus Omega = I
% object pose
Omega = eye(5);

% contact point with Table, Bin and Hand
p_OHC = p_WH0 - p_WO0;
p_OTC = [-kObjectLength/2; -kObjectThickness/2];
p_OBC = [-kObjectLength/2; kObjectThickness/2];
% goal
goal_velocity_z = kGoalRotationVelocity*kObjectLength*cos(theta);
G = [0 1 0 0 0];
b_G = goal_velocity_z;

% Holonomic constraints
Jac_phi_q_all = jac_phi_q_flip_against_corner(p_WO, theta, p_WH, p_OHC, p_OTC, p_OBC);
% return;

% external force
F_WGO = [0 -kObjectMass*kGravityConstant]';
F_WGH = [0 -kHandMass*kGravityConstant]';
F = [F_WGO; 0; F_WGH];

% Guard Conditions
%   Inequality A*lambda<b_A
%       hand contact is sticking; (force is in world frame)
%       hand contact normal force lower bound
%       table contact normal force lower bound
%       table contact normal force upper bound
%       binwall contact normal force lower bound
%       binwall contact normal force upper bound

%   Equality Aeq*lambda = beq
%       table contact is sliding;
%       bin wall contact is sliding;
% lambda: f_why, f_whx, f_table_normal, f_binwall_normal,
%         f_table_friction, f_binwall_friction
A = zeros(2 + 1 + 4, kDimLambda + kDimSlidingFriction + kDimGeneralized);
y = [1 0]';
z = [0 1]';
A(1, 1:2) = (z' - kFrictionCoefficientHand*y')*(R_WO');
A(2, 1:2) = (-z' - kFrictionCoefficientHand*y')*(R_WO');
A(3, 1:2) = -y'*(R_WO');
A(4, 3) = -1;
A(5, 3) = 1;
A(6, 4) = -1;
A(7, 4) = 1;
b_A = [0 0 -kMinNormalForce -kMinNormalForceSliding kMaxNormalForceSliding ...
        -kMinNormalForceSliding kMaxNormalForceSliding]';

Aeq = zeros(2, kDimLambda + kDimSlidingFriction + kDimGeneralized);
% % % -y'*ftable = mu*z'*ftable
Aeq(1, [5, 3]) = kFrictionCoefficientTable*z'+y';
% % z'*f = mu*y'*f
Aeq(2, [4, 6]) = kFrictionCoefficientBin*y'-z';
beq = [0; 0];


dims.Actualized      = kDimActualized;
dims.UnActualized    = kDimUnActualized;
dims.SlidingFriction = kDimSlidingFriction;
dims.Lambda          = kDimLambda;

[n_av, n_af, R_a, w_av, eta_af] = solvehfvc(Omega, Jac_phi_q_all, ...
        G, b_G, F, Aeq, beq, A, b_A, dims, 'num_seeds', 3);



================================================
FILE: examples/flip_against_corner/symbolic_derivation_of_gradients_flip_against_corner.m
================================================
% Derive jacobian function for 'flip against corner' example.

clear;clc;
% symbols
p_WO     = sym('p_WO',[2,1],'real');  % position of object in world frame
theta    = sym('theta', 'real');  % object tilting angle, start from 0
p_WH     = sym('p_WH',[2,1],'real');  % position of hand in world frame

%   location of object contacts in object frame
p_OHC = sym('p_OHC', [2,1], 'real'); % contact with hand
p_OTC = sym('p_OTC', [2,1], 'real'); % contact with table
p_OBC = sym('p_OBC', [2,1], 'real'); % contact with bin wall

% 2D rotation matrix
R_WO = aa2mat(theta, [1 0 0]');
R_WO = R_WO(2:3, 2:3);

% all the holonomic constraints
holonomic_constraint = sym('Phi', [6, 1], 'real');
% Hand contact
holonomic_constraint(1:2) = p_WH - (R_WO*p_OHC+p_WO);
% table non-penetration
holonomic_constraint(3) = [0 1] * (R_WO*p_OTC+p_WO);
% bin wall non-penetration
holonomic_constraint(4) = [1 0] * (R_WO*p_OBC+p_WO);
% table sliding
holonomic_constraint(5) = [1 0] * (R_WO*p_OTC+p_WO);
% bin wall sliding friction
holonomic_constraint(6) = [0 1] * (R_WO*p_OBC+p_WO);

holonomic_constraint = simplify(holonomic_constraint);

save generated/derivation.mat;
disp('Computing derivatives:');

%% ---------------------------------------------------------------
%           calculate derivatives
% ---------------------------------------------------------------
% load generated/derivation
deriv_q  = @(f) [
        diff(f,'p_WO1'), diff(f,'p_WO2'), ...
        diff(f,'theta'), ...
        diff(f,'p_WH1'), diff(f,'p_WH2')];

Phi_q  = simplify(deriv_q(holonomic_constraint));
disp('Done. Generating file:');

%% ---------------------------------------------------------------
%           write to file
% ---------------------------------------------------------------
matlabFunction(Phi_q, 'File', 'generated/jac_phi_q_flip_against_corner', ...
    'vars', {p_WO, theta, p_WH, p_OHC, p_OTC, p_OBC});
save generated/derivation.mat;
disp('All done');



================================================
FILE: experiments/cleanstart.m
================================================
close all force;
clear classes;
clear;
clc;

interface


================================================
FILE: experiments/interface.fig
================================================
[Binary file]


================================================
FILE: experiments/interface.m
================================================
function varargout = interface(varargin)
% INTERFACE MATLAB code for interface.fig
%      INTERFACE, by itself, creates a new INTERFACE or raises the existing
%      singleton*.
%
%      H = INTERFACE returns the handle to a new INTERFACE or the handle to
%      the existing singleton*.
%
%      INTERFACE('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in INTERFACE.M with the given input arguments.
%
%      INTERFACE('Property','Value',...) creates a new INTERFACE or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before interface_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to interface_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help interface

% Last Modified by GUIDE v2.5 13-Sep-2018 22:45:29

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @interface_OpeningFcn, ...
                   'gui_OutputFcn',  @interface_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before interface is made visible.
function [] = interface_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to interface (see VARARGIN)

% Choose default command line output for interface
handles.output = hObject;

% Update handles structure
guidata(hObject, handles);

% UIWAIT makes interface wait for user response (see UIRESUME)
% uiwait(handles.figure1);
addpath ../derivation
addpath ../derivation/generated
clc

% --- Outputs from this function are returned to the command line.
function varargout = interface_OutputFcn(hObject, eventdata, handles)
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;

% ---------------------------------------------------------------------
%       User Defined Functionalities
% ---------------------------------------------------------------------
addpath ../examples/block_tilting
addpath ../examples/bottle_rotation
addpath ../examples/flip_against_corner


% --- Executes on button press in BTN_EXP_Init_ROS.
function BTN_EXP_Init_ROS_Callback(hObject, eventdata, handles)
% hObject    handle to BTN_EXP_Init_ROS (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global reset_client read_obj_pose_client get_robot_pose_client move_tool_client
global move_hybrid_client move_until_touch_client

% rosinit;

reset_client            = rossvcclient('/robot_bridge/reset');
get_robot_pose_client   = rossvcclient('/robot_bridge/get_pose');
move_tool_client        = rossvcclient('/robot_bridge/move_tool');
move_hybrid_client      = rossvcclient('/robot_bridge/move_hybrid');
move_until_touch_client = rossvcclient('/robot_bridge/move_until_touch');

set(handles.BTN_EXP_Init_ROS, 'Enable', 'off');
set(handles.BTN_EXP_Reset, 'Enable', 'on');
set(handles.BTN_EXP_read_obj_pose, 'Enable', 'on');
set(handles.BTN_EXP_Pre_Grasp, 'Enable', 'off');
set(handles.BTN_EXP_Engage, 'Enable', 'off');
set(handles.BTN_EXP_Planning, 'Enable', 'off');
% set(handles.BTN_EXP_Run, 'Enable', 'off');
set(handles.BTN_EXP_Release_Reset, 'Enable', 'off');

disp('Initialization is done. Service clients are ready to use.');

% --- Executes on button press in BTN_EXP_Reset.
function BTN_EXP_Reset_Callback(hObject, eventdata, handles)
% hObject    handle to BTN_EXP_Reset (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global reset_client
disp('Calling Reset_service:');
call(reset_client);
disp('Reset is done.');

set(handles.BTN_EXP_Init_ROS, 'Enable', 'off');
set(handles.BTN_EXP_Reset, 'Enable', 'off');
set(handles.BTN_EXP_read_obj_pose, 'Enable', 'on');
set(handles.BTN_EXP_Pre_Grasp, 'Enable', 'off');
set(handles.BTN_EXP_Engage, 'Enable', 'off');
set(handles.BTN_EXP_Planning, 'Enable', 'off');
set(handles.BTN_EXP_Release_Reset, 'Enable', 'off');

% --- Executes on button press in BTN_EXP_read_obj_pose.
function BTN_EXP_read_obj_pose_Callback(hObject, eventdata, handles)
% hObject    handle to BTN_EXP_read_obj_pose (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global read_obj_pose_client inputs

% disp('Calling read_obj_pose service:');
% call(read_obj_pose_client);

% p_WCenter0 is a point on the table surface;
% p_WO is defined as the middle point of the pivoting edge, not the object center
switch get(get(handles.BTNGROUP_select_experiment,'SelectedObject'),'Tag')
    case 'RBTN_block_tilting'
        inputs.kNumberOfSteps = 15;
        inputs.kTimeStep = 0.3; % s
        inputs.ObjectEdgeLength = 0.075;
        % inputs.zTableTop = 0.259;
        p_WCenter0 = [41.5 398.15 257]'/1000;
        switch get(get(handles.BTNGROUP_block_tilting_direction,'SelectedObject'),'Tag')
            case 'RBTN_X_plus'
                inputs.p_WO0 = p_WCenter0 + ...
                        [inputs.ObjectEdgeLength/2, 0, 0]';
                inputs.TiltDirection = [1 0 0]';
                inputs.m_project = diag([1 0 1]);
            case 'RBTN_Y_minus'
                inputs.p_WO0 = p_WCenter0 + ...
                        [inputs.ObjectEdgeLength, -inputs.ObjectEdgeLength/2, 0]';
                inputs.TiltDirection = [0 -1 0]';
                inputs.m_project = diag([0 1 1]);
            case 'RBTN_X_minus'
                inputs.p_WO0 = p_WCenter0 + ...
                        [inputs.ObjectEdgeLength/2, -inputs.ObjectEdgeLength, 0]';
                inputs.TiltDirection = [-1 0 0]';
                inputs.m_project = diag([1 0 1]);
            case 'RBTN_Y_plus'
                inputs.p_WO0 = p_WCenter0 + ...
                        [0, -inputs.ObjectEdgeLength/2, 0]';
                inputs.TiltDirection = [0 1 0]';
                inputs.m_project = diag([0 1 1]);
            otherwise
                error('[Error] unknown selected object.');
        end
        inputs.p_WH0 = inputs.p_WO0 - ...
                0.15*inputs.ObjectEdgeLength*inputs.TiltDirection + ...
                [0 0 inputs.ObjectEdgeLength]';
        inputs.p_WHPrepare_mm = 1000*(inputs.p_WH0 + [0 0 0.2*inputs.ObjectEdgeLength]');
        % write parameters to file
        fp = fopen(['../results/block_tilting/para.txt'],'w');
        fprintf(fp, '%d\n', inputs.kNumberOfSteps);
        fprintf(fp, '%f\n', inputs.kTimeStep); % length of a timestep
        fprintf(fp, '%f\n', 0.5); % object mass
        fprintf(fp, '%f\n', 0.3); % hand mass
        fprintf(fp, '%f\n', 9.8); % gravity constant
        fprintf(fp, '%f\n', 0.8); % friction coef table object
        fprintf(fp, '%f\n', 0.8); % friction coef hand object
        fprintf(fp, '%d\n', 6); % friction polyhedron sides
        fprintf(fp, '%f\n', 10); % min normal force (newton)
        fprintf(fp, '%f\n', inputs.ObjectEdgeLength);
        fprintf(fp, '%f %f %f\n', inputs.p_WH0(1),...
                inputs.p_WH0(2), inputs.p_WH0(3));
        fprintf(fp, '%f %f %f\n', inputs.p_WO0(1),...
                inputs.p_WO0(2), inputs.p_WO0(3));
        fprintf(fp, '%f %f %f\n', inputs.TiltDirection(1),...
                inputs.TiltDirection(2), inputs.TiltDirection(3));
        fclose(fp);

    case 'RBTN_flip_against_corner'
        inputs.p_WHPrepare_mm   = [30 385 268]; % block
%         inputs.p_WHPrepare_mm   = [30 415 260.5]; % cell phone

    otherwise
        error('[Error] unknown selected object.');
end
disp('Parameter file is written.');

set(handles.BTN_EXP_Pre_Grasp, 'Enable', 'on');
set(handles.BTN_EXP_Engage, 'Enable', 'off');
set(handles.BTN_EXP_Planning, 'Enable', 'off');
set(handles.BTN_EXP_Release_Reset, 'Enable', 'off');

disp('Read obj pose is done.');


% --- Executes on button press in BTN_EXP_Pre_Grasp.
function BTN_EXP_Pre_Grasp_Callback(hObject, eventdata, handles)
% hObject    handle to BTN_EXP_Pre_Grasp (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global move_tool_client get_robot_pose_client inputs

% obtain orientation
call(get_robot_pose_client);
fp_feedback   = fopen('../results/pose_feedback.txt','r');
pose_feedback = fscanf(fp_feedback, '%f');
fclose(fp_feedback);

assert(length(pose_feedback) == 7);

pose_set      = pose_feedback;
pose_set(1:3) = inputs.p_WHPrepare_mm;
% warning('Hacked here!!!!');
% pose_set = [30 410 268 0.11626 0.5394 -0.81523 0.17587];

fp = fopen('../results/pose_set.txt','w');
fprintf(fp, '%f ', pose_set);
fclose(fp);

disp('Calling move_tool_service:');
call(move_tool_client);

set(handles.BTN_EXP_Init_ROS, 'Enable', 'off');
set(handles.BTN_EXP_Reset, 'Enable', 'on');
set(handles.BTN_EXP_read_obj_pose, 'Enable', 'off');
set(handles.BTN_EXP_Pre_Grasp, 'Enable', 'off');
set(handles.BTN_EXP_Engage, 'Enable', 'on');
set(handles.BTN_EXP_Planning, 'Enable', 'off');
set(handles.BTN_EXP_Release_Reset, 'Enable', 'off');

disp('Pre Grasp is done.');

% --- Executes on button press in BTN_EXP_Engage.
function BTN_EXP_Engage_Callback(hObject, eventdata, handles)
% hObject    handle to BTN_EXP_Engage (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global move_until_touch_client get_robot_pose_client

switch get(get(handles.BTNGROUP_select_experiment,'SelectedObject'),'Tag')
    case 'RBTN_block_tilting'
        velocity_set = 5*[0 0 -1]'; % mm/s
    case 'RBTN_flip_against_corner'
        velocity_set = 10*[0 -1 0]'; % mm/s
    otherwise
        error('[Error] unknown selected object.');
end

fp = fopen('../results/velocity_set.txt','w');
fprintf(fp, '%f ', velocity_set);
fclose(fp);

disp('Calling move_until_touch_service:');
call(move_until_touch_client);

% % feedback
% call(get_robot_pose_client);
% fp_feedback = fopen(['../results/pose_feedback.txt'],'r');
% pose_feedback = fscanf(fp_feedback, '%f');
% fclose(fp_feedback);
% pose_feedback(1:3) = pose_feedback(1:3)/1000;

set(handles.BTN_EXP_Init_ROS, 'Enable', 'off');
set(handles.BTN_EXP_Reset, 'Enable', 'on');
set(handles.BTN_EXP_read_obj_pose, 'Enable', 'off');
set(handles.BTN_EXP_Pre_Grasp, 'Enable', 'off');
set(handles.BTN_EXP_Engage, 'Enable', 'on');
set(handles.BTN_EXP_Planning, 'Enable', 'on');
set(handles.BTN_EXP_Release_Reset, 'Enable', 'off');

disp('Engaging is done.');

% --- Executes on button press in BTN_EXP_Planning.
function BTN_EXP_Planning_Callback(hObject, eventdata, handles)
% hObject    handle to BTN_EXP_Planning (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
clc;
global get_robot_pose_client move_hybrid_client move_tool_client inputs

disp('[Planning] Planning begin.');

switch get(get(handles.BTNGROUP_select_experiment,'SelectedObject'),'Tag')
    case 'RBTN_block_tilting'
        kTotalRotationAngle = 50*pi/180;
    case 'RBTN_flip_against_corner'
        kTotalRotationAngle = 50*pi/180;
    otherwise
        error('[Error] unknown selected object.');
end

% Generate state trajectory
% print parameters to file
switch get(get(handles.BTNGROUP_select_experiment,'SelectedObject'),'Tag')
    case 'RBTN_block_tilting'
        traj.p_WH = zeros(3, inputs.kNumberOfSteps);
        traj.p_WO = zeros(3, inputs.kNumberOfSteps);
        traj.q_WO = zeros(4, inputs.kNumberOfSteps);

        kRotateAxis = cross([0 0 1]', inputs.TiltDirection);

        for i = 1:inputs.kNumberOfSteps
            angle_i = kTotalRotationAngle/inputs.kNumberOfSteps*i;
            traj.p_WO(:, i) = inputs.p_WO0;
            traj.q_WO(:, i) = aa2quat(angle_i, kRotateAxis);
            traj.p_WH(:, i) = ...
                    quatOnVec(inputs.p_WH0 - inputs.p_WO0, traj.q_WO(:, i)) ...
                    + inputs.p_WO0;
        end
        fp_p_WH = fopen(['../results/block_tilting/p_WH.txt'],'w');
        fp_p_WO = fopen(['../results/block_tilting/p_WO.txt'],'w');
        fp_q_WO = fopen(['../results/block_tilting/q_WO.txt'],'w');
        for i = 1:inputs.kNumberOfSteps
            fprintf(fp_p_WH, '%f\n', traj.p_WH(:,i));
            fprintf(fp_p_WO, '%f\n', traj.p_WO(:,i));
            fprintf(fp_q_WO, '%f\n', traj.q_WO(:,i));
        end
        fclose(fp_p_WH);
        fclose(fp_p_WO);
        fclose(fp_q_WO);

        % p_WO = p_WO0;
        % v_C2C0 = p_WH0 - p_LineContact;
        % q_WO = quatBTVec(m_project*v_C2C0, m_project*(p_WH - p_WO));
        % inputs.p_WH = pose_feedback(1:3);
        % p_WO = inputs.p_WO0;
        % v_C2C0 = inputs.p_WH0 - inputs.p_WO0;
        % angle_rotated = angBTVec(inputs.m_project*v_C2C0, inputs.m_project*(inputs.p_WH - p_WO));
    case 'RBTN_flip_against_corner'
        % obtain orientation
        call(get_robot_pose_client);
        fp_feedback   = fopen('../results/pose_feedback.txt','r');
        pose_feedback = fscanf(fp_feedback, '%f');
        fclose(fp_feedback);

        kGoalTheta            = 45/180*pi;
        kTimeStep             = 0.1; % s
        kGoalRotationVelocity = 0.1;
        kObjectLength         = 75;
        kObjectThickness      = 35;
        kHandHeight0          = 14.5; %7
        p_WH0 = pose_feedback(2:3)/1000; %[400.4 268]'/1000;
        p_WO0 = p_WH0 - [6.5+kObjectLength/2;
                kHandHeight0 - kObjectThickness/2]/1000; %[44; -9.5]

        fp = fopen(['../results/flip_against_corner/para.txt'],'w');
        fprintf(fp, '%f\n', kGoalTheta);
        fprintf(fp, '%f\n', kTimeStep); % length of a timestep
        fprintf(fp, '%f\n', 0.15); % object mass
        fprintf(fp, '%f\n', 0.0); % hand mass
        fprintf(fp, '%f\n', 9.8); % gravity constant
        fprintf(fp, '%f\n', kObjectLength/1000); % 0.075 object length
        fprintf(fp, '%f\n', kObjectThickness/1000); % 0.035 object thickness
        fprintf(fp, '%f\n', 0.5); % friction coef table object
        fprintf(fp, '%f\n', 0.7); % friction coef hand object
        fprintf(fp, '%f\n', 0.5); % friction coef bin object
        fprintf(fp, '%f\n', 4); % min normal force
        fprintf(fp, '%f\n', -5); % min normal force sliding
        fprintf(fp, '%f\n', 100); % max normal force sliding
        fprintf(fp, '%f\n', kGoalRotationVelocity); % Goal rotation velocity
        fprintf(fp, '%f %f\n', p_WH0(1), p_WH0(2));
        fprintf(fp, '%f %f\n', p_WO0(1), p_WO0(2));
        fclose(fp);
end

disp('Calling move_hybrid_service:');
call(move_hybrid_client);

% disengage
switch get(get(handles.BTNGROUP_select_experiment,'SelectedObject'),'Tag')
    case 'RBTN_block_tilting'
        call(get_robot_pose_client);
        fp_feedback   = fopen('../results/pose_feedback.txt','r');
        pose_feedback = fscanf(fp_feedback, '%f');
        fclose(fp_feedback);

        pose_set = pose_feedback;
        pose_set(1:3) = pose_set(1:3) + inputs.TiltDirection*40; % mm
        % pose_set(1:3) = pose_set(1:3)*1000;
        fp = fopen(['../results/pose_set.txt'],'w');
        fprintf(fp, '%f ', pose_set);
        fclose(fp);
        disp('Calling move_tool_service:');
        call(move_tool_client);

    case 'RBTN_flip_against_corner'
        % call(get_robot_pose_client);
        % fp_feedback   = fopen('../results/pose_feedback.txt','r');
        % pose_feedback = fscanf(fp_feedback, '%f');
        % fclose(fp_feedback);

        % pose_set = pose_feedback;
        % pose_set(3) = pose_set(3) + 30; % mm
        % fp = fopen(['../results/pose_set.txt'],'w');
        % fprintf(fp, '%f ', pose_set);
        % fclose(fp);
        % disp('Calling move_tool_service:');
        % call(move_tool_client);
end

set(handles.BTN_EXP_Planning, 'Enable', 'off');
set(handles.BTN_EXP_Release_Reset, 'Enable', 'on');

disp('Planning is done.')



% --- Executes on button press in BTN_EXP_Release_Reset.
function BTN_EXP_Release_Reset_Callback(hObject, eventdata, handles)
% hObject    handle to BTN_EXP_Release_Reset (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
global get_robot_pose_client move_tool_client inputs reset_client

% read feedback
call(get_robot_pose_client);
fp_feedback = fopen('../results/pose_feedback.txt','r');
pose_feedback = fscanf(fp_feedback, '%f');
fclose(fp_feedback);

% move up to release
pose_set = pose_feedback;
pose_set(3) = pose_set(3) + 30;
fp = fopen('../results/pose_set.txt','w');
fprintf(fp, '%f ', pose_set);
fclose(fp);

disp('Calling move_tool_service:');
call(move_tool_client);

% call reset
call(reset_client);

set(handles.BTN_EXP_Init_ROS, 'Enable', 'off');
set(handles.BTN_EXP_Reset, 'Enable', 'on');
set(handles.BTN_EXP_read_obj_pose, 'Enable', 'on');
set(handles.BTN_EXP_Pre_Grasp, 'Enable', 'off');
set(handles.BTN_EXP_Engage, 'Enable', 'off');
set(handles.BTN_EXP_Planning, 'Enable', 'off');
set(handles.BTN_EXP_Release_Reset, 'Enable', 'off');
disp('Release_reset is done.');

% --- Executes on button press in RBTN_X_plus.
function RBTN_X_plus_Callback(hObject, eventdata, handles)
% hObject    handle to RBTN_X_plus (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of RBTN_X_plus


